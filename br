#!/usr/bin/env bash

# ============================================
# Beads-Ralphy - Autonomous AI Coding Loop (Beads Edition)
# Supports Claude Code, OpenCode, Codex, Cursor, Qwen-Code, Factory Droid and Gemini CLI
# Runs until all tasks are complete
# ============================================

set -euo pipefail

# ============================================
# CONFIGURATION & DEFAULTS
# ============================================

VERSION="4.0.0"

# Ralphy config directory
RALPHY_DIR=".ralphy"
CONFIG_FILE="$RALPHY_DIR/config.yaml"
SINGLE_TASK=""
INIT_MODE=false
SHOW_CONFIG=false
ADD_RULE=""
AUTO_COMMIT=true

# Bead creation options for single task mode
BEAD_TYPE="task"        # Default bead type for single tasks
BEAD_LABELS=""          # Additional labels beyond "ralph"

# Runtime options
AI_ENGINE="claude"  # claude, opencode, cursor, codex, qwen, or droid
DRY_RUN=false
MAX_ITERATIONS=0  # 0 = unlimited
MAX_RETRIES=3
RETRY_DELAY=5
VERBOSE=false

# Git branch options
BRANCH_PER_TASK=false
CREATE_PR=false
BASE_BRANCH=""
PR_DRAFT=false

# Parallel execution
PARALLEL=false
MAX_PARALLEL=3

# Beads source options
BEADS_LABEL="ralph"  # Default label filter for tasks

# Colors (detect if terminal supports colors)
if [[ -t 1 ]] && command -v tput &>/dev/null && [[ $(tput colors 2>/dev/null || echo 0) -ge 8 ]]; then
  RED=$(tput setaf 1)
  GREEN=$(tput setaf 2)
  YELLOW=$(tput setaf 3)
  BLUE=$(tput setaf 4)
  MAGENTA=$(tput setaf 5)
  CYAN=$(tput setaf 6)
  BOLD=$(tput bold)
  DIM=$(tput dim)
  RESET=$(tput sgr0)
else
  RED="" GREEN="" YELLOW="" BLUE="" MAGENTA="" CYAN="" BOLD="" DIM="" RESET=""
fi

# Global state
ai_pid=""
monitor_pid=""
tmpfile=""
CODEX_LAST_MESSAGE_FILE=""
current_step="Thinking"
total_input_tokens=0
total_output_tokens=0
total_actual_cost="0"  # OpenCode provides actual cost
total_duration_ms=0    # Cursor provides duration
iteration=0
retry_count=0
declare -a parallel_pids=()
declare -a task_branches=()
declare -a integration_branches=()  # Track integration branches for cleanup on interrupt
WORKTREE_BASE=""  # Base directory for parallel agent worktrees
ORIGINAL_DIR=""   # Original working directory (for worktree operations)
ORIGINAL_BASE_BRANCH=""  # Original base branch before integration branches
BR_START_TIME=""  # Execution start time (epoch seconds)
BR_END_TIME=""    # Execution end time (epoch seconds)
BR_DURATION_SEC=0 # Total execution duration in seconds

# ============================================
# UTILITY FUNCTIONS
# ============================================

log_info() {
  echo "${BLUE}â„¹${RESET} $*"
}

log_success() {
  echo "${GREEN}âœ“${RESET} $*"
}

log_warn() {
  echo "${YELLOW}âš ${RESET} $*"
}

log_error() {
  echo "${RED}âœ—${RESET} $*" >&2
}

log_debug() {
  if [[ "$VERBOSE" == true ]]; then
    echo "${DIM}â€¢ $*${RESET}"
  fi
}

# Show progress bar
show_progress_bar() {
  local completed=$1
  local total=$2
  local bar_width=16

  if [[ $total -eq 0 ]]; then
    return
  fi

  local filled=$((completed * bar_width / total))
  local empty=$((bar_width - filled))
  local percent=$((completed * 100 / total))

  printf "  ${DIM}Progress:${RESET} ${GREEN}"
  printf 'â–ˆ%.0s' $(seq 1 $filled)
  printf "${DIM}"
  printf 'â–‘%.0s' $(seq 1 $empty)
  printf "${RESET} ${CYAN}%d/%d${RESET} ${DIM}(%d%%)${RESET}\n" $completed $total $percent
}

# Format large numbers with K suffix
format_token_count() {
  local num=$1
  if [[ $num -ge 1000 ]]; then
    local k=$((num / 1000))
    local remainder=$((num % 1000))
    local decimal=$((remainder / 100))
    echo "${k}.${decimal}K"
  else
    echo "$num"
  fi
}

# Extract token info from output file
extract_token_info() {
  local file=$1
  # Parse JSON output for token counts
  local input_tokens=$(grep '"input_tokens"' "$file" 2>/dev/null | tail -1 | grep -o '[0-9]\+' || echo "0")
  local output_tokens=$(grep '"output_tokens"' "$file" 2>/dev/null | tail -1 | grep -o '[0-9]\+' || echo "0")

  if [[ $input_tokens -gt 0 ]] || [[ $output_tokens -gt 0 ]]; then
    local input_fmt=$(format_token_count "$input_tokens")
    local output_fmt=$(format_token_count "$output_tokens")
    echo "[${input_fmt}â†’${output_fmt} tokens]"
  else
    echo ""
  fi
}

# Slugify text for branch names
slugify() {
  echo "$1" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9]+/-/g' | sed -E 's/^-|-$//g' | cut -c1-50
}

# ============================================
# BROWNFIELD MODE (.ralphy/ configuration)
# ============================================

# Initialize .ralphy/ directory with config files
init_ralphy_config() {
  if [[ -d "$RALPHY_DIR" ]]; then
    log_warn "$RALPHY_DIR already exists"
    REPLY='N'  # Default if read times out or fails
    read -p "Overwrite config? [y/N] " -n 1 -r -t 30 2>/dev/null || true
    echo
    [[ ! $REPLY =~ ^[Yy]$ ]] && exit 0
  fi

  mkdir -p "$RALPHY_DIR"

  # Smart detection
  local project_name=""
  local lang=""
  local framework=""
  local test_cmd=""
  local lint_cmd=""
  local build_cmd=""

  # Get project name from directory or package.json
  project_name=$(basename "$PWD")

  if [[ -f "package.json" ]]; then
    # Get name from package.json if available
    local pkg_name
    pkg_name=$(jq -r '.name // ""' package.json 2>/dev/null)
    [[ -n "$pkg_name" ]] && project_name="$pkg_name"

    # Detect language
    if [[ -f "tsconfig.json" ]]; then
      lang="TypeScript"
    else
      lang="JavaScript"
    fi

    # Detect frameworks from dependencies (collect all matches)
    local deps
    local frameworks=()
    deps=$(jq -r '(.dependencies // {}) + (.devDependencies // {}) | keys[]' package.json 2>/dev/null || true)

    # Use grep for reliable exact matching
    echo "$deps" | grep -qx "next" && frameworks+=("Next.js")
    echo "$deps" | grep -qx "nuxt" && frameworks+=("Nuxt")
    echo "$deps" | grep -qx "@remix-run/react" && frameworks+=("Remix")
    echo "$deps" | grep -qx "svelte" && frameworks+=("Svelte")
    echo "$deps" | grep -qE "@nestjs/" && frameworks+=("NestJS")
    echo "$deps" | grep -qx "hono" && frameworks+=("Hono")
    echo "$deps" | grep -qx "fastify" && frameworks+=("Fastify")
    echo "$deps" | grep -qx "express" && frameworks+=("Express")
    # Only add React/Vue if no meta-framework detected
    if [[ ${#frameworks[@]} -eq 0 ]]; then
      echo "$deps" | grep -qx "react" && frameworks+=("React")
      echo "$deps" | grep -qx "vue" && frameworks+=("Vue")
    fi

    # Join frameworks with comma
    if [[ ${#frameworks[@]} -gt 0 ]]; then
      framework=$(IFS=', '; echo "${frameworks[*]}")
    fi

    # Detect commands from package.json scripts
    local scripts
    scripts=$(jq -r '.scripts // {}' package.json 2>/dev/null)

    # Test command (prefer bun if lockfile exists)
    if echo "$scripts" | jq -e '.test' >/dev/null 2>&1; then
      test_cmd="npm test"
      [[ -f "bun.lockb" ]] && test_cmd="bun test"
    fi

    # Lint command
    if echo "$scripts" | jq -e '.lint' >/dev/null 2>&1; then
      lint_cmd="npm run lint"
    fi

    # Build command
    if echo "$scripts" | jq -e '.build' >/dev/null 2>&1; then
      build_cmd="npm run build"
    fi

  elif [[ -f "pyproject.toml" ]] || [[ -f "requirements.txt" ]] || [[ -f "setup.py" ]]; then
    lang="Python"
    local py_frameworks=()
    local py_deps=""
    [[ -f "pyproject.toml" ]] && py_deps=$(cat pyproject.toml 2>/dev/null)
    [[ -f "requirements.txt" ]] && py_deps+=$(cat requirements.txt 2>/dev/null)
    echo "$py_deps" | grep -qi "fastapi" && py_frameworks+=("FastAPI")
    echo "$py_deps" | grep -qi "django" && py_frameworks+=("Django")
    echo "$py_deps" | grep -qi "flask" && py_frameworks+=("Flask")
    if [[ ${#py_frameworks[@]} -gt 0 ]]; then
      framework=$(IFS=', '; echo "${py_frameworks[*]}")
    fi
    test_cmd="pytest"
    lint_cmd="ruff check ."

  elif [[ -f "go.mod" ]]; then
    lang="Go"
    test_cmd="go test ./..."
    lint_cmd="golangci-lint run"

  elif [[ -f "Cargo.toml" ]]; then
    lang="Rust"
    test_cmd="cargo test"
    lint_cmd="cargo clippy"
    build_cmd="cargo build"

  elif [[ -f "gleam.toml" ]]; then
    lang="Gleam"
    test_cmd="gleam test"
    lint_cmd="gleam format ."
    build_cmd="gleam build"
  fi

  # Show what we detected
  echo ""
  echo "${BOLD}Detected:${RESET}"
  echo "  Project:   ${CYAN}$project_name${RESET}"
  [[ -n "$lang" ]] && echo "  Language:  ${CYAN}$lang${RESET}"
  [[ -n "$framework" ]] && echo "  Framework: ${CYAN}$framework${RESET}"
  [[ -n "$test_cmd" ]] && echo "  Test:      ${CYAN}$test_cmd${RESET}"
  [[ -n "$lint_cmd" ]] && echo "  Lint:      ${CYAN}$lint_cmd${RESET}"
  [[ -n "$build_cmd" ]] && echo "  Build:     ${CYAN}$build_cmd${RESET}"
  echo ""

  # Escape values for safe YAML (double quotes inside strings)
  yaml_escape() { printf '%s' "$1" | sed 's/"/\\"/g'; }

  # Create config.yaml with detected values
  cat > "$CONFIG_FILE" << EOF
# Ralphy Configuration
# https://github.com/mssoka/beads-ralphy

# Project info (auto-detected, edit if needed)
project:
  name: "$(yaml_escape "$project_name")"
  language: "$(yaml_escape "${lang:-Unknown}")"
  framework: "$(yaml_escape "${framework:-}")"
  description: ""  # Add a brief description

# Commands (auto-detected from package.json/pyproject.toml)
commands:
  test: "$(yaml_escape "${test_cmd:-}")"
  lint: "$(yaml_escape "${lint_cmd:-}")"
  build: "$(yaml_escape "${build_cmd:-}")"

# Rules - instructions the AI MUST follow
# These are injected into every prompt
rules: []
  # Examples:
  # - "Always use TypeScript strict mode"
  # - "Follow the error handling pattern in src/utils/errors.ts"
  # - "All API endpoints must have input validation with Zod"
  # - "Use server actions instead of API routes in Next.js"

# Boundaries - files/folders the AI should not modify
boundaries:
  never_touch: []
    # Examples:
    # - "src/legacy/**"
    # - "migrations/**"
    # - "*.lock"
EOF

  log_success "Created $RALPHY_DIR/"
  echo ""
  echo "  ${CYAN}$CONFIG_FILE${RESET}   - Your rules and preferences"
  echo ""
  echo "${BOLD}Next steps:${RESET}"
  echo "  1. Add rules:  ${CYAN}br --add-rule \"your rule here\"${RESET}"
  echo "  2. Or edit:    ${CYAN}$CONFIG_FILE${RESET}"
  echo "  3. Run:        ${CYAN}br \"your task\"${RESET} or ${CYAN}br${RESET} (in beads project)"
}

# Validate .ralphy/config.yaml syntax and structure
validate_config() {
  # Return silently if no config (brownfield mode)
  [[ ! -f "$CONFIG_FILE" ]] && return 0

  # Check YAML syntax
  if command -v yq &>/dev/null; then
    if ! yq eval '.' "$CONFIG_FILE" >/dev/null 2>&1; then
      log_error "Invalid YAML syntax in $CONFIG_FILE"
      log_info "Run: yq eval '.' $CONFIG_FILE to see error"
      exit 1
    fi
  elif command -v python3 &>/dev/null; then
    # Fallback: use python to validate YAML
    if ! python3 -c "import yaml; yaml.safe_load(open('$CONFIG_FILE'))" 2>/dev/null; then
      log_error "Invalid YAML syntax in $CONFIG_FILE"
      exit 1
    fi
  fi

  # If yq available, do deeper validation
  if command -v yq &>/dev/null; then
    # Check for project.name (recommended field)
    local project_name
    project_name=$(yq -r '.project.name // ""' "$CONFIG_FILE" 2>/dev/null)
    if [[ -z "$project_name" ]]; then
      log_warn "Config missing 'project.name'. Run: br --init"
    fi

    # Validate known top-level keys
    local known_keys=("project" "commands" "rules" "boundaries")
    local actual_keys
    actual_keys=$(yq -r 'keys | .[]' "$CONFIG_FILE" 2>/dev/null)

    while IFS= read -r key; do
      if [[ -n "$key" ]] && [[ ! " ${known_keys[*]} " =~ " ${key} " ]]; then
        log_warn "Unknown config key: '$key' in $CONFIG_FILE"
      fi
    done <<< "$actual_keys"

    # Validate glob patterns in boundaries.never_touch
    local patterns
    patterns=$(yq -r '.boundaries.never_touch // [] | .[]' "$CONFIG_FILE" 2>/dev/null)

    if [[ -n "$patterns" ]]; then
      while IFS= read -r pattern; do
        # Basic validation: check for invalid glob chars
        if [[ "$pattern" =~ [^a-zA-Z0-9/*._-] ]]; then
          log_warn "Glob pattern may be invalid: '$pattern'"
        fi
      done <<< "$patterns"
    fi
  fi

  return 0
}

# Load rules from config.yaml
load_ralphy_rules() {
  [[ ! -f "$CONFIG_FILE" ]] && return

  if command -v yq &>/dev/null; then
    yq -r '.rules // [] | .[]' "$CONFIG_FILE" 2>/dev/null || true
  fi
}

# Load boundaries from config.yaml
load_ralphy_boundaries() {
  local boundary_type="$1"  # never_touch or always_test
  [[ ! -f "$CONFIG_FILE" ]] && return

  if command -v yq &>/dev/null; then
    yq -r ".boundaries.$boundary_type // [] | .[]" "$CONFIG_FILE" 2>/dev/null || true
  fi
}

# Show current config
show_ralphy_config() {
  if [[ ! -f "$CONFIG_FILE" ]]; then
    log_warn "No config found. Run 'ralphy --init' first."
    exit 1
  fi

  echo ""
  echo "${BOLD}â•­â”€ Ralphy Configuration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®${RESET}"
  echo "${BOLD}â”‚${RESET}"

  if command -v yq &>/dev/null; then
    # Project section
    echo "${BOLD}â”‚${RESET}  ${CYAN}ðŸ“¦ Project${RESET}"
    local name=$(yq -r '.project.name // ""' "$CONFIG_FILE" 2>/dev/null)
    local lang=$(yq -r '.project.language // ""' "$CONFIG_FILE" 2>/dev/null)
    local framework=$(yq -r '.project.framework // ""' "$CONFIG_FILE" 2>/dev/null)

    [[ -n "$name" ]] && echo "${BOLD}â”‚${RESET}  ${DIM}â”œâ”€ Name:       ${RESET}$name"
    [[ -n "$lang" ]] && echo "${BOLD}â”‚${RESET}  ${DIM}â”œâ”€ Language:   ${RESET}$lang"
    [[ -n "$framework" ]] && echo "${BOLD}â”‚${RESET}  ${DIM}â””â”€ Framework:  ${RESET}$framework"

    # Commands section
    echo "${BOLD}â”‚${RESET}"
    echo "${BOLD}â”‚${RESET}  ${CYAN}âš™ï¸  Commands${RESET}"
    local test_cmd=$(yq -r '.commands.test // ""' "$CONFIG_FILE" 2>/dev/null)
    local lint_cmd=$(yq -r '.commands.lint // ""' "$CONFIG_FILE" 2>/dev/null)
    local build_cmd=$(yq -r '.commands.build // ""' "$CONFIG_FILE" 2>/dev/null)

    local has_test=false
    local has_lint=false
    local has_build=false
    [[ -n "$test_cmd" ]] && has_test=true
    [[ -n "$lint_cmd" ]] && has_lint=true
    [[ -n "$build_cmd" ]] && has_build=true

    if [[ "$has_test" == true ]]; then
      if [[ "$has_lint" == true ]] || [[ "$has_build" == true ]]; then
        echo "${BOLD}â”‚${RESET}  ${DIM}â”œâ”€ Test:   ${RESET}$test_cmd"
      else
        echo "${BOLD}â”‚${RESET}  ${DIM}â””â”€ Test:   ${RESET}$test_cmd"
      fi
    fi

    if [[ "$has_lint" == true ]]; then
      if [[ "$has_build" == true ]]; then
        echo "${BOLD}â”‚${RESET}  ${DIM}â”œâ”€ Lint:   ${RESET}$lint_cmd"
      else
        echo "${BOLD}â”‚${RESET}  ${DIM}â””â”€ Lint:   ${RESET}$lint_cmd"
      fi
    fi

    [[ "$has_build" == true ]] && echo "${BOLD}â”‚${RESET}  ${DIM}â””â”€ Build:  ${RESET}$build_cmd"

    # Rules section
    local rules_count=$(yq -r '.rules // [] | length' "$CONFIG_FILE" 2>/dev/null)
    if [[ "$rules_count" -gt 0 ]]; then
      echo "${BOLD}â”‚${RESET}"
      echo "${BOLD}â”‚${RESET}  ${CYAN}ðŸ“‹ Rules ($rules_count)${RESET}"

      local rules_json=$(yq -r '.rules // []' "$CONFIG_FILE" 2>/dev/null)
      local i=0
      while [[ $i -lt $rules_count ]]; do
        local rule=$(echo "$rules_json" | yq -r ".[$i]" 2>/dev/null)
        if [[ $((i + 1)) -eq $rules_count ]]; then
          echo "${BOLD}â”‚${RESET}  ${DIM}â””â”€ $rule${RESET}"
        else
          echo "${BOLD}â”‚${RESET}  ${DIM}â”œâ”€ $rule${RESET}"
        fi
        ((i++))
      done
    fi

    # Boundaries section
    local never_touch_count=$(yq -r '.boundaries.never_touch // [] | length' "$CONFIG_FILE" 2>/dev/null)
    if [[ "$never_touch_count" -gt 0 ]]; then
      echo "${BOLD}â”‚${RESET}"
      echo "${BOLD}â”‚${RESET}  ${CYAN}ðŸš« Never Touch ($never_touch_count)${RESET}"

      local boundaries_json=$(yq -r '.boundaries.never_touch // []' "$CONFIG_FILE" 2>/dev/null)
      local i=0
      while [[ $i -lt $never_touch_count ]]; do
        local path=$(echo "$boundaries_json" | yq -r ".[$i]" 2>/dev/null)
        if [[ $((i + 1)) -eq $never_touch_count ]]; then
          echo "${BOLD}â”‚${RESET}  ${DIM}â””â”€ $path${RESET}"
        else
          echo "${BOLD}â”‚${RESET}  ${DIM}â”œâ”€ $path${RESET}"
        fi
        ((i++))
      done
    fi
  else
    # Fallback: just show the file
    echo "${BOLD}â”‚${RESET}  ${DIM}(yq not installed - showing raw YAML)${RESET}"
    echo "${BOLD}â”‚${RESET}"
    cat "$CONFIG_FILE" | while IFS= read -r line; do
      echo "${BOLD}â”‚${RESET}  $line"
    done
  fi

  echo "${BOLD}â”‚${RESET}"
  echo "${BOLD}â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯${RESET}"
}

# Add a rule to config.yaml
add_ralphy_rule() {
  local rule="$1"

  if [[ ! -f "$CONFIG_FILE" ]]; then
    log_error "No config found. Run 'ralphy --init' first."
    exit 1
  fi

  if ! command -v yq &>/dev/null; then
    log_error "yq is required to add rules. Install from https://github.com/mikefarah/yq"
    log_info "Or manually edit $CONFIG_FILE"
    exit 1
  fi

  # Add rule to the rules array (use env var to avoid YAML injection)
  RULE="$rule" yq -i '.rules += [env(RULE)]' "$CONFIG_FILE"
  log_success "Added rule: $rule"
}

# Load test command from config
load_test_command() {
  [[ ! -f "$CONFIG_FILE" ]] && echo "" && return

  if command -v yq &>/dev/null; then
    yq -r '.commands.test // ""' "$CONFIG_FILE" 2>/dev/null || echo ""
  else
    echo ""
  fi
}

# Load project context from config.yaml
load_project_context() {
  [[ ! -f "$CONFIG_FILE" ]] && return

  if command -v yq &>/dev/null; then
    local name lang framework desc
    name=$(yq -r '.project.name // ""' "$CONFIG_FILE" 2>/dev/null)
    lang=$(yq -r '.project.language // ""' "$CONFIG_FILE" 2>/dev/null)
    framework=$(yq -r '.project.framework // ""' "$CONFIG_FILE" 2>/dev/null)
    desc=$(yq -r '.project.description // ""' "$CONFIG_FILE" 2>/dev/null)

    local context=""
    [[ -n "$name" ]] && context+="Project: $name\n"
    [[ -n "$lang" ]] && context+="Language: $lang\n"
    [[ -n "$framework" ]] && context+="Framework: $framework\n"
    [[ -n "$desc" ]] && context+="Description: $desc\n"
    echo -e "$context"
  fi
}

# Log task to progress file
# Build prompt with beads task context
build_beads_prompt() {
  local task="$1"
  local task_id=$(echo "$task" | cut -d: -f1)

  # Get task details from beads
  local task_data=$(bd show "$task_id" --json 2>/dev/null | jq '.[0]')
  local title=$(echo "$task_data" | jq -r '.title')
  local description=$(echo "$task_data" | jq -r '.description // ""')
  local design=$(echo "$task_data" | jq -r '.design // ""')
  local acceptance=$(echo "$task_data" | jq -r '.acceptance // ""')

  local prompt=""

  # Add project context if available
  local context
  context=$(load_project_context)
  if [[ -n "$context" ]]; then
    prompt+="## Project Context
$context

"
  fi

  # Add rules if available
  local rules
  rules=$(load_ralphy_rules)
  if [[ -n "$rules" ]]; then
    prompt+="## Rules (you MUST follow these)
$rules

"
  fi

  # Add boundaries
  local never_touch
  never_touch=$(load_ralphy_boundaries "never_touch")
  if [[ -n "$never_touch" ]]; then
    prompt+="## Boundaries
Do NOT modify these files/directories:
$never_touch

"
  fi

  # Add instructions for fetching related task context
  prompt+="## Related Task Context (Optional)

If you need context from recently completed related tasks, run:

  bd list --json 2>/dev/null | jq -r '
    .[] |
    select(.status == \"closed\") |
    select(.labels | index(\"${BEADS_LABEL}\")) |
    .id + \": \" + .title
  ' | head -5

These are recently closed tasks. Use 'bd show <id>' to read details.

"

  # Add task details
  prompt+="## Task: $task_id - $title
"

  if [[ -n "$description" ]]; then
    prompt+="
### Description
$description
"
  fi

  if [[ -n "$design" ]]; then
    prompt+="
### Design Approach
$design
"
  fi

  if [[ -n "$acceptance" ]]; then
    prompt+="
### Acceptance Criteria
$acceptance
"
  fi

  prompt+="
## Instructions
1. Review recently completed tasks above for patterns and gotchas
2. Implement the task following the design approach
3. Verify all acceptance criteria are met
4. Run tests and verify they pass
   - Determine the appropriate test command for this project
   - All tests must pass before marking complete
5. Run build and verify it succeeds
   - Determine the appropriate build command for this project
   - Build must complete without errors before marking complete"

  # Add commit instruction only if auto-commit is enabled
  local step_num=6
  if [[ "$AUTO_COMMIT" == "true" ]]; then
    prompt+="
$step_num. Commit your changes with a descriptive message"
    step_num=7
  fi

  prompt+="
$step_num. Update this task's notes with what you learned:
   bd update $task_id --notes 'Brief summary of: patterns discovered, gotchas encountered, implementation approach'

## Completion Signal
When THIS TASK is complete (after updating notes), output <promise>COMPLETE</promise>

Keep changes focused and minimal. Do not refactor unrelated code."

  echo "$prompt"
}

# Run a single brownfield task
run_brownfield_task() {
  local task="$1"

  echo ""
  echo "${BOLD}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${RESET}"
  echo "${BOLD}Task:${RESET} $task"
  echo "${BOLD}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${RESET}"
  echo ""

  local prompt
  prompt=$(build_beads_prompt "$task")

  # Create temp file for output
  local output_file
  output_file=$(mktemp)

  log_info "Running with $AI_ENGINE..."

  # Run the AI engine (tee to show output while saving for parsing)
  case "$AI_ENGINE" in
    claude)
      claude --dangerously-skip-permissions \
        -p "$prompt" 2>&1 | tee "$output_file"
      ;;
    opencode)
      opencode --output-format stream-json \
        --approval-mode full-auto \
        "$prompt" 2>&1 | tee "$output_file"
      ;;
    cursor)
      agent --dangerously-skip-permissions \
        -p "$prompt" 2>&1 | tee "$output_file"
      ;;
    qwen)
      qwen --output-format stream-json \
        --approval-mode yolo \
        -p "$prompt" 2>&1 | tee "$output_file"
      ;;
    droid)
      droid exec --output-format stream-json \
        --auto medium \
        "$prompt" 2>&1 | tee "$output_file"
      ;;
    codex)
      codex exec --full-auto \
        --json \
        "$prompt" 2>&1 | tee "$output_file"
      ;;
    gemini)
      gemini --output-format stream-json \
        --approval-mode yolo \
        "$prompt" 2>&1 | tee "$output_file"
      ;;
  esac

  local exit_code=$?

  # Log result
  if [[ $exit_code -eq 0 ]]; then
    log_success "Task completed"
  else
    log_error "Task failed"
  fi

  rm -f "$output_file"
  return $exit_code
}

# ============================================
# BEAD CREATION FOR SINGLE TASK MODE
# ============================================

create_bead_from_task() {
  local task_description="$1"
  local bead_type="${BEAD_TYPE:-task}"
  local additional_labels="${BEAD_LABELS:-}"

  # Combine "ralph" with any additional labels
  local final_labels="ralph"
  if [[ -n "$additional_labels" ]]; then
    final_labels="ralph,${additional_labels}"
  fi

  # Create the bead
  local create_output
  if ! create_output=$(bd create \
    --title "$task_description" \
    --type "$bead_type" \
    --labels "$final_labels" \
    --description "Auto-created by br for single task execution" 2>&1); then
    log_error "Failed to create bead: $create_output"
    return 1
  fi

  # Extract bead ID from output (bd create outputs the bead ID)
  local bead_id
  if [[ "$create_output" =~ (ralphy-[a-z0-9]+) ]]; then
    bead_id="${BASH_REMATCH[1]}"
    log_success "Created bead: $bead_id (type: $bead_type, labels: $final_labels)" >&2
    echo "$bead_id"
    return 0
  else
    log_error "Could not extract bead ID from output: $create_output"
    return 1
  fi
}

# ============================================
# HELP & VERSION
# ============================================

show_help() {
  cat << EOF
${BOLD}Ralphy${RESET} - Autonomous AI Coding Loop (v${VERSION})

${BOLD}USAGE:${RESET}
  ./br [options]        # Beads mode (requires .beads/ directory)
  ./br "task"           # Single task mode (brownfield)
  ./br --init           # Initialize .ralphy/ config

${BOLD}CONFIG & SETUP:${RESET}
  --init              Initialize .ralphy/ with smart defaults
  --config            Show current configuration
  --add-rule "..."    Add a rule to config (e.g., "Always use Zod")

${BOLD}SINGLE TASK MODE:${RESET}
  "task description"  Run a single task (auto-creates bead, quotes required)
  --type TYPE         Bead type: task, bug, feature, epic, chore (default: task)
  --labels LABELS     Additional labels (comma-separated, always includes "ralph")
  --no-commit         Don't auto-commit after task completion

${BOLD}AI ENGINE OPTIONS:${RESET}
  --claude            Use Claude Code (default)
  --opencode          Use OpenCode
  --cursor            Use Cursor agent
  --codex             Use Codex CLI
  --qwen              Use Qwen-Code
  --droid             Use Factory Droid
  --gemini            Use Gemini CLI

${BOLD}EXECUTION OPTIONS:${RESET}
  --max-iterations N  Stop after N iterations (0 = unlimited)
  --max-retries N     Max retries per task on failure (default: 3)
  --retry-delay N     Seconds between retries (default: 5)
  --dry-run           Show what would be done without executing

${BOLD}PARALLEL EXECUTION:${RESET}
  --parallel          Run independent tasks in parallel
  --max-parallel N    Max concurrent tasks (default: 3)

${BOLD}GIT BRANCH OPTIONS:${RESET}
  --branch-per-task   Create a new git branch for each task
  --base-branch NAME  Base branch to create task branches from (default: current)
  --create-pr         Create a pull request after each task (requires gh CLI)
  --draft-pr          Create PRs as drafts

${BOLD}BEADS OPTIONS:${RESET}
  --label TAG         Filter tasks by label (default: ralph)

${BOLD}OTHER OPTIONS:${RESET}
  -v, --verbose       Show debug output
  -h, --help          Show this help
  --version           Show version number

${BOLD}EXAMPLES:${RESET}
  # Single task mode (auto-creates beads)
  ./br --init                             # Initialize config
  ./br "add dark mode toggle"             # Run single task (type: task, labels: ralph)
  ./br "fix login bug" --type bug         # Create bug-type bead
  ./br "add tests" --labels ci,testing    # Additional labels: ralph,ci,testing
  ./br "refactor auth" --type chore --labels security,backend --opencode

  # Beads mode (works on tasks from beads tracker)
  ./br                              # Run with Claude Code (ralph label)
  ./br --codex                      # Run with Codex CLI
  ./br --label critical             # Only process 'critical' labeled tasks
  ./br --parallel --max-parallel 4  # Run 4 tasks concurrently
  ./br --branch-per-task --create-pr  # Feature branch workflow

${BOLD}BEADS INTEGRATION:${RESET}
  Single task mode auto-creates beads with "ralph" label
  Beads mode requires .beads/ directory with beads issue tracker
  Filters tasks by label (default: ralph)
  Automatically respects task dependencies

EOF
}

show_version() {
  echo "Ralphy v${VERSION}"
}

# ============================================
# ARGUMENT PARSING
# ============================================

parse_args() {
  while [[ $# -gt 0 ]]; do
    case $1 in
      --opencode)
        AI_ENGINE="opencode"
        shift
        ;;
      --claude)
        AI_ENGINE="claude"
        shift
        ;;
      --cursor|--agent)
        AI_ENGINE="cursor"
        shift
        ;;
      --codex)
        AI_ENGINE="codex"
        shift
        ;;
      --qwen)
        AI_ENGINE="qwen"
        shift
        ;;
      --droid)
        AI_ENGINE="droid"
        shift
        ;;
      --gemini)
        AI_ENGINE="gemini"
        shift
        ;;
      --dry-run)
        DRY_RUN=true
        shift
        ;;
      --max-iterations)
        MAX_ITERATIONS="${2:-0}"
        shift 2
        ;;
      --max-retries)
        MAX_RETRIES="${2:-3}"
        shift 2
        ;;
      --retry-delay)
        RETRY_DELAY="${2:-5}"
        shift 2
        ;;
      --parallel)
        PARALLEL=true
        shift
        ;;
      --max-parallel)
        MAX_PARALLEL="${2:-3}"
        shift 2
        ;;
      --branch-per-task)
        BRANCH_PER_TASK=true
        shift
        ;;
      --base-branch)
        BASE_BRANCH="${2:-}"
        shift 2
        ;;
      --create-pr)
        CREATE_PR=true
        shift
        ;;
      --draft-pr)
        PR_DRAFT=true
        shift
        ;;
      --type)
        BEAD_TYPE="${2:-task}"
        shift 2
        ;;
      --labels)
        BEAD_LABELS="${2:-}"
        shift 2
        ;;
      --label)
        BEADS_LABEL="${2:-ralph}"
        shift 2
        ;;
      -v|--verbose)
        VERBOSE=true
        shift
        ;;
      -h|--help)
        show_help
        exit 0
        ;;
      --version)
        show_version
        exit 0
        ;;
      --init)
        INIT_MODE=true
        shift
        ;;
      --config)
        SHOW_CONFIG=true
        shift
        ;;
      --add-rule)
        [[ -z "${2:-}" ]] && { log_error "--add-rule requires an argument"; exit 1; }
        ADD_RULE="$2"
        shift 2
        ;;
      --no-commit)
        AUTO_COMMIT=false
        shift
        ;;
      -*)
        log_error "Unknown option: $1"
        echo "Use --help for usage"
        exit 1
        ;;
      *)
        # Positional argument = single task (brownfield mode)
        if [[ -z "$SINGLE_TASK" ]]; then
          SINGLE_TASK="$1"
        else
          SINGLE_TASK="$SINGLE_TASK $1"
        fi
        shift
        ;;
    esac
  done
}

# ============================================
# PRE-FLIGHT CHECKS
# ============================================

check_requirements() {
  local missing=()

  # Check for beads requirements
  if ! command -v jq &>/dev/null; then
    log_error "jq is required. Install from: https://jqlang.github.io/jq/"
    exit 1
  fi

  if ! command -v bd &>/dev/null; then
    log_error "bd CLI not found."
    log_info "Install from: https://github.com/onbeam/beads"
    exit 1
  fi

  if [[ ! -d ".beads" ]]; then
    log_error "No .beads directory found. Initialize with: bd init"
    exit 1
  fi

  # Check for AI CLI
  case "$AI_ENGINE" in
    opencode)
      if ! command -v opencode &>/dev/null; then
        log_error "OpenCode CLI not found."
        log_info "Install from: https://opencode.ai/docs/"
        exit 1
      fi
      ;;
    codex)
      if ! command -v codex &>/dev/null; then
        log_error "Codex CLI not found."
        log_info "Make sure 'codex' is in your PATH."
        exit 1
      fi
      ;;
    cursor)
      if ! command -v agent &>/dev/null; then
        log_error "Cursor agent CLI not found."
        log_info "Make sure Cursor is installed and 'agent' is in your PATH."
        exit 1
      fi
      ;;
    qwen)
      if ! command -v qwen &>/dev/null; then
        log_error "Qwen-Code CLI not found."
        log_info "Make sure 'qwen' is in your PATH."
        exit 1
      fi
      ;;
    droid)
      if ! command -v droid &>/dev/null; then
        log_error "Factory Droid CLI not found. Install from https://docs.factory.ai/cli/getting-started/quickstart"
        exit 1
      fi
      ;;
    gemini)
      if ! command -v gemini &>/dev/null; then
        log_error "Gemini CLI not found."
        log_info "Install from: https://github.com/google/gemini-cli"
        exit 1
      fi
      ;;
    *)
      if ! command -v claude &>/dev/null; then
        log_error "Claude Code CLI not found."
        log_info "Install from: https://github.com/anthropics/claude-code"
        log_info "Or use another engine: --cursor, --opencode, --codex, --qwen"
        exit 1
      fi
      ;;
  esac

  # Check for jq (required for JSON parsing)
  if ! command -v jq &>/dev/null; then
    log_error "jq is required but not installed. On Linux, install with: apt-get install jq (Debian/Ubuntu) or yum install jq (RHEL/CentOS)"
    exit 1
  fi

  # Check for gh if PR creation is requested
  if [[ "$CREATE_PR" == true ]] && ! command -v gh &>/dev/null; then
    log_error "GitHub CLI (gh) is required for --create-pr. Install from https://cli.github.com/"
    exit 1
  fi

  if [[ ${#missing[@]} -gt 0 ]]; then
    log_warn "Missing optional dependencies: ${missing[*]}"
    log_warn "Some features may not work properly"
  fi

  # Check for git
  if ! command -v git &>/dev/null; then
    log_error "git is required but not installed. Install git before running Ralphy."
    exit 1
  fi

  # Check if we're in a git repository
  if ! git rev-parse --git-dir >/dev/null 2>&1; then
    log_error "Not a git repository. Ralphy requires a git repository to track changes."
    exit 1
  fi

  # Ensure .ralphy/ directory exists
  mkdir -p "$RALPHY_DIR"

  # Set base branch if not specified
  if [[ "$BRANCH_PER_TASK" == true ]] && [[ -z "$BASE_BRANCH" ]]; then
    BASE_BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "main")
    log_debug "Using base branch: $BASE_BRANCH"
  fi
}

# ============================================
# CLEANUP HANDLER
# ============================================

cleanup() {
  local exit_code=$?
  
  # Kill background processes
  [[ -n "$monitor_pid" ]] && kill "$monitor_pid" 2>/dev/null || true
  [[ -n "$ai_pid" ]] && kill "$ai_pid" 2>/dev/null || true
  
  # Kill parallel processes
  for pid in "${parallel_pids[@]+"${parallel_pids[@]}"}"; do
    kill "$pid" 2>/dev/null || true
  done
  
  # Kill any remaining child processes
  pkill -P $$ 2>/dev/null || true
  
  # Remove temp file
  [[ -n "$tmpfile" ]] && rm -f "$tmpfile"
  [[ -n "$CODEX_LAST_MESSAGE_FILE" ]] && rm -f "$CODEX_LAST_MESSAGE_FILE"
  
  # Cleanup parallel worktrees
  if [[ -n "$WORKTREE_BASE" ]] && [[ -d "$WORKTREE_BASE" ]]; then
    # Remove all worktrees we created
    for dir in "$WORKTREE_BASE"/agent-*; do
      if [[ -d "$dir" ]]; then
        if git -C "$dir" status --porcelain 2>/dev/null | grep -q .; then
          log_warn "Preserving dirty worktree: $dir"
          continue
        fi
        git worktree remove "$dir" 2>/dev/null || true
      fi
    done
    if ! find "$WORKTREE_BASE" -maxdepth 1 -type d -name 'agent-*' -print -quit 2>/dev/null | grep -q .; then
      rm -rf "$WORKTREE_BASE" 2>/dev/null || true
    else
      log_warn "Preserving worktree base with dirty agents: $WORKTREE_BASE"
    fi
  fi
  
  # Show message on interrupt
  if [[ $exit_code -eq 130 ]]; then
    printf "\n"
    log_warn "Interrupted! Cleaning up..."

    # Revert all in_progress tasks back to open
    if command -v bd &>/dev/null; then
      revert_in_progress_tasks
    else
      log_warn "bd command not found, cannot revert tasks"
    fi

    # Show branches created if any
    if [[ -n "${task_branches[*]+"${task_branches[*]}"}" ]]; then
      log_info "Branches created: ${task_branches[*]}"
    fi

    # Show integration branches if any (for parallel group workflows)
    if [[ -n "${integration_branches[*]+"${integration_branches[*]}"}" ]]; then
      log_info "Integration branches: ${integration_branches[*]}"
      if [[ -n "$ORIGINAL_BASE_BRANCH" ]]; then
        log_info "To resume: merge integration branches into $ORIGINAL_BASE_BRANCH"
      fi
    fi
  fi
}

# ============================================
# TASK SOURCES - BEADS (GLOBAL)
# ============================================

get_tasks_beads() {
  # Get all open tasks with label filter (exclude epics)
  local label_filter="${BEADS_LABEL:-ralph}"

  bd list --json 2>/dev/null | \
    jq -r --arg label "$label_filter" '.[] |
           select(.status == "open") |
           select(.issue_type != "epic") |
           select(.labels | index($label)) |
           .id + ":" + .title' || true
}

get_next_task_beads() {
  # Get top-ranked task from BD list (exclude epics)
  local label_filter="${BEADS_LABEL:-ralph}"

  bd list --json 2>/dev/null | \
    jq -r --arg label "$label_filter" '.[] |
           select(.status == "open") |
           select(.issue_type != "epic") |
           select(.labels | index($label)) |
           .id + ":" + .title' | \
    head -1 | cut -c1-70 || echo ""
}

count_remaining_beads() {
  # Count open tasks with label
  local label_filter="${BEADS_LABEL:-ralph}"

  bd list --status=open --limit 0 --json 2>/dev/null | \
    jq --arg label "$label_filter" \
      '[.[] | select(.labels | index($label))] | length' || echo "0"
}

count_completed_beads() {
  # Count closed tasks with label
  local label_filter="${BEADS_LABEL:-ralph}"

  bd list --status=closed --limit 0 --json 2>/dev/null | \
    jq --arg label "$label_filter" \
      '[.[] | select(.labels | index($label))] | length' || echo "0"
}

mark_task_complete_beads() {
  local task=$1
  local task_id=$(echo "$task" | cut -d: -f1)

  log_debug "Closing beads task: $task_id"
  bd close "$task_id" 2>&1 | grep -v '^$' || true
}

mark_task_in_progress_beads() {
  local task=$1
  local task_id=$(echo "$task" | cut -d: -f1)

  log_debug "Marking beads task in progress: $task_id"
  bd update "$task_id" --status=in_progress 2>&1 | grep -v '^$' || true
}

mark_task_failed_beads() {
  local task=$1
  local task_id=$(echo "$task" | cut -d: -f1)

  log_debug "Reverting failed task to open: $task_id"
  bd update "$task_id" --status=open 2>&1 | grep -v '^$' || true
}

revert_in_progress_tasks() {
  # Revert all in_progress tasks with the label back to open
  local label_filter="${BEADS_LABEL:-ralph}"

  log_debug "Reverting in_progress tasks with label '$label_filter' to open"

  # Get all in_progress task IDs with the label
  local task_ids
  task_ids=$(bd list --status=in_progress --json 2>/dev/null | \
    jq -r --arg label "$label_filter" '.[] |
           select(.labels | index($label)) |
           .id' 2>/dev/null || true)

  if [[ -z "$task_ids" ]]; then
    log_debug "No in_progress tasks to revert"
    return 0
  fi

  # Revert each task
  while IFS= read -r task_id; do
    [[ -z "$task_id" ]] && continue
    log_info "Reverting $task_id to open"
    bd update "$task_id" --status=open 2>&1 || {
      log_error "Failed to revert $task_id"
    }
  done <<< "$task_ids"
}

check_and_close_parent_epic() {
  local task_id=$1

  # Check if task has a parent (contains a dot)
  if [[ ! "$task_id" =~ \. ]]; then
    return 0
  fi

  # Extract parent epic ID (everything before the last dot)
  local epic_id="${task_id%.*}"

  log_debug "Checking if parent epic $epic_id should be closed"

  # Get all children of this epic
  local all_children=$(bd list --json 2>/dev/null | \
    jq -r --arg epic "$epic_id" '[.[] | select(.id | startswith($epic + "."))] | length' 2>/dev/null)

  if [[ -z "$all_children" ]] || [[ "$all_children" == "0" ]]; then
    log_debug "No children found for epic $epic_id"
    return 0
  fi

  # Get count of open children
  local open_children=$(bd list --json 2>/dev/null | \
    jq -r --arg epic "$epic_id" '[.[] | select(.id | startswith($epic + ".")) | select(.status == "open")] | length' 2>/dev/null)

  if [[ "$open_children" == "0" ]]; then
    log_info "All children of epic $epic_id are closed, closing epic"
    bd close "$epic_id" 2>&1 | grep -v '^$' || true
  else
    log_debug "Epic $epic_id has $open_children open children remaining"
  fi
}

cleanup_all_completed_epics() {
  # Find all epics where all children are closed
  log_debug "Running final epic cleanup"

  local epics=$(bd list --json 2>/dev/null | \
    jq -r '[.[] | select(.status == "open") | select(.id | test("^[^.]+$"))] | .[].id' 2>/dev/null)

  while IFS= read -r epic_id; do
    if [[ -n "$epic_id" ]]; then
      # Check if this epic has any open children
      local open_children=$(bd list --json 2>/dev/null | \
        jq -r --arg epic "$epic_id" '[.[] | select(.id | startswith($epic + ".")) | select(.status == "open")] | length' 2>/dev/null)

      if [[ "$open_children" == "0" ]]; then
        # Check if epic has any children at all
        local total_children=$(bd list --json 2>/dev/null | \
          jq -r --arg epic "$epic_id" '[.[] | select(.id | startswith($epic + "."))] | length' 2>/dev/null)

        if [[ "$total_children" != "0" ]]; then
          log_info "Closing completed epic: $epic_id"
          bd close "$epic_id" 2>&1 | grep -v '^$' || true
        fi
      fi
    fi
  done <<< "$epics"
}

get_beads_parallel_levels() {
  # Get execution levels based on dependency depth using bd dep list
  # Level = number of open blockers (level-0 = no blockers, level-1 = 1 blocker, etc.)
  local label_filter="${BEADS_LABEL:-ralph}"

  # Get all open tasks with label filter (exclude epics)
  local task_ids=$(bd list --json 2>/dev/null | \
    jq -r --arg label "$label_filter" '.[] |
      select(.status == "open") |
      select(.issue_type != "epic") |
      select(.labels | index($label)) |
      .id')

  if [[ -z "$task_ids" ]]; then
    echo "level-0"
    return
  fi

  # For each task, count its open blockers and track the level
  local levels_found=()
  while IFS= read -r task_id; do
    [[ -z "$task_id" ]] && continue

    # Get blocking dependencies (tasks that block this task)
    local blocker_count=$(bd dep list "$task_id" --json --direction=down --type blocks 2>/dev/null | \
      jq '[.[] | select(.status == "open")] | length' 2>/dev/null || echo "0")

    # Track this level if we haven't seen it yet
    if [[ ${#levels_found[@]} -eq 0 ]] || [[ ! " ${levels_found[@]} " =~ " ${blocker_count} " ]]; then
      levels_found+=("$blocker_count")
    fi
  done <<< "$task_ids"

  # Output sorted levels as level-0, level-1, etc.
  if [[ ${#levels_found[@]} -gt 0 ]]; then
    printf '%s\n' "${levels_found[@]}" | sort -n | sed 's/^/level-/'
  else
    echo "level-0"
  fi
}

get_tasks_in_level_beads() {
  local level=$1
  local label_filter="${BEADS_LABEL:-ralph}"

  # Extract level number from level-N format
  local level_num="${level#level-}"

  # Get all open tasks with label filter (exclude epics)
  local tasks_json=$(bd list --json 2>/dev/null | \
    jq --arg label "$label_filter" '[.[] |
      select(.status == "open") |
      select(.issue_type != "epic") |
      select(.labels | index($label))]')

  if [[ -z "$tasks_json" ]] || [[ "$tasks_json" == "[]" ]]; then
    return
  fi

  # For each task, count blockers and output if it matches the requested level
  echo "$tasks_json" | jq -r '.[] | .id' | while IFS= read -r task_id; do
    [[ -z "$task_id" ]] && continue

    # Get blocking dependencies (tasks that block this task)
    local blocker_count=$(bd dep list "$task_id" --json --direction=down --type blocks 2>/dev/null | \
      jq '[.[] | select(.status == "open")] | length' 2>/dev/null || echo "0")

    # If this task's blocker count matches the requested level, output it
    if [[ "$blocker_count" == "$level_num" ]]; then
      # Get task title from the tasks_json
      local title=$(echo "$tasks_json" | jq -r --arg id "$task_id" '.[] | select(.id == $id) | .title')
      echo "${task_id}:${title}"
    fi
  done
}

# ============================================
# TASK INTERFACE (Direct calls to beads functions)
# ============================================

get_next_task() {
  get_next_task_beads
}

get_all_tasks() {
  get_tasks_beads
}

count_remaining_tasks() {
  count_remaining_beads
}

count_completed_tasks() {
  count_completed_beads
}

mark_task_complete() {
  mark_task_complete_beads "$1"
}

mark_task_in_progress() {
  mark_task_in_progress_beads "$1"
}

mark_task_failed() {
  mark_task_failed_beads "$1"
}

# ============================================
# GIT BRANCH MANAGEMENT
# ============================================

create_task_branch() {
  local task=$1
  local branch_name="ralphy/$(slugify "$task")"
  
  log_debug "Creating branch: $branch_name from $BASE_BRANCH"
  
  # Stash any changes (only pop if a new stash was created)
  local stash_before stash_after stashed=false
  stash_before=$(git stash list -1 --format='%gd %s' 2>/dev/null || true)
  git stash push -m "ralphy-autostash" >/dev/null 2>&1 || true
  stash_after=$(git stash list -1 --format='%gd %s' 2>/dev/null || true)
  if [[ -n "$stash_after" ]] && [[ "$stash_after" != "$stash_before" ]] && [[ "$stash_after" == *"ralphy-autostash"* ]]; then
    stashed=true
  fi
  
  # Create and checkout new branch
  git checkout "$BASE_BRANCH" 2>/dev/null || true
  git pull origin "$BASE_BRANCH" 2>/dev/null || true
  git checkout -b "$branch_name" 2>/dev/null || {
    # Branch might already exist
    git checkout "$branch_name" 2>/dev/null || true
  }
  
  # Pop stash if we stashed
  if [[ "$stashed" == true ]]; then
    git stash pop >/dev/null 2>&1 || true
  fi
  
  task_branches+=("$branch_name")
  echo "$branch_name"
}

create_pull_request() {
  local branch=$1
  local task=$2
  local body="${3:-Automated PR created by Ralphy}"
  
  local draft_flag=""
  [[ "$PR_DRAFT" == true ]] && draft_flag="--draft"
  
  log_info "Creating pull request for $branch..."
  
  # Push branch first
  git push -u origin "$branch" 2>/dev/null || {
    log_warn "Failed to push branch $branch"
    return 1
  }
  
  # Create PR
  local pr_url
  pr_url=$(gh pr create \
    --base "$BASE_BRANCH" \
    --head "$branch" \
    --title "$task" \
    --body "$body" \
    $draft_flag 2>/dev/null) || {
    log_warn "Failed to create PR for $branch"
    return 1
  }
  
  log_success "PR created: $pr_url"
  echo "$pr_url"
}

return_to_base_branch() {
  if [[ "$BRANCH_PER_TASK" == true ]]; then
    git checkout "$BASE_BRANCH" 2>/dev/null || true
  fi
}

# ============================================
# PROGRESS MONITOR
# ============================================

monitor_progress() {
  local file=$1
  local task=$2
  local start_time
  start_time=$(date +%s)
  local spinstr='â ‹â ™â ¹â ¸â ¼â ´â ¦â §â ‡â '
  local spin_idx=0

  while true; do
    local elapsed=$(($(date +%s) - start_time))
    local mins=$((elapsed / 60))
    local secs=$((elapsed % 60))

    # Check latest output for step indicators
    if [[ -f "$file" ]] && [[ -s "$file" ]]; then
      local content
      content=$(tail -c 5000 "$file" 2>/dev/null || true)

      if echo "$content" | grep -qE 'git commit|"command":"git commit'; then
        current_step="Committing"
      elif echo "$content" | grep -qE 'git add|"command":"git add'; then
        current_step="Staging"
      elif echo "$content" | grep -qE 'bd close|bd update'; then
        current_step="Updating task status"
      elif echo "$content" | grep -qE 'lint|eslint|biome|prettier|gleam format'; then
        current_step="Linting"
      elif echo "$content" | grep -qE 'vitest|jest|bun test|npm test|pytest|go test|gleam test'; then
        current_step="Testing"
      elif echo "$content" | grep -qE 'gleam build|cargo build|npm run build|go build'; then
        current_step="Building"
      elif echo "$content" | grep -qE '\.test\.|\.spec\.|__tests__|_test\.go'; then
        current_step="Writing tests"
      elif echo "$content" | grep -qE '"tool":"[Ww]rite"|"tool":"[Ee]dit"|"name":"write"|"name":"edit"'; then
        current_step="Implementing"
      elif echo "$content" | grep -qE '"tool":"[Rr]ead"|"tool":"[Gg]lob"|"tool":"[Gg]rep"|"name":"read"|"name":"glob"|"name":"grep"'; then
        current_step="Reading code"
      fi
    fi

    local spinner_char="${spinstr:$spin_idx:1}"
    local step_color=""

    # Color-code steps
    case "$current_step" in
      "Thinking"|"Reading code") step_color="$CYAN" ;;
      "Implementing"|"Writing tests") step_color="$MAGENTA" ;;
      "Testing"|"Linting"|"Building") step_color="$YELLOW" ;;
      "Staging"|"Committing") step_color="$GREEN" ;;
      *) step_color="$BLUE" ;;
    esac

    # Get terminal width and calculate available space for task name
    local term_width
    term_width=$(tput cols 2>/dev/null || echo 80)
    # Format: "  X Step-name-16ch â”‚ task-name [MM:SS]"
    # Fixed parts: "  " (2) + spinner (1) + " " (1) + step (16) + " â”‚ " (3) + " [" (2) + "MM:SS" (5) + "]" (1) = 31 chars
    local fixed_width=31
    local available_width=$((term_width - fixed_width))

    # Ensure we have at least 10 chars for task name, otherwise truncate more aggressively
    if [[ $available_width -lt 10 ]]; then
      available_width=10
    fi

    local truncated_task="${task:0:$available_width}"

    # Move to beginning of line, clear from cursor to end of screen (handles wrapped lines)
    # \r = carriage return (move to start of line)
    # \033[J = clear from cursor to end of screen
    printf "\r\033[J  %s ${step_color}%-16s${RESET} â”‚ %s ${DIM}[%02d:%02d]${RESET}" "$spinner_char" "$current_step" "$truncated_task" "$mins" "$secs"

    spin_idx=$(( (spin_idx + 1) % ${#spinstr} ))
    sleep 0.12
  done
}

# ============================================
# NOTIFICATION (Cross-platform)
# ============================================

notify_done() {
  local message="${1:-Ralphy has completed all tasks!}"
  
  # macOS
  if command -v afplay &>/dev/null; then
    afplay /System/Library/Sounds/Glass.aiff 2>/dev/null &
  fi
  
  # macOS notification
  if command -v osascript &>/dev/null; then
    osascript -e "display notification \"$message\" with title \"Ralphy\"" 2>/dev/null || true
  fi
  
  # Linux (notify-send)
  if command -v notify-send &>/dev/null; then
    notify-send "Ralphy" "$message" 2>/dev/null || true
  fi
  
  # Linux (paplay for sound)
  if command -v paplay &>/dev/null; then
    paplay /usr/share/sounds/freedesktop/stereo/complete.oga 2>/dev/null &
  fi
  
  # Windows (powershell)
  if command -v powershell.exe &>/dev/null; then
    powershell.exe -Command "[System.Media.SystemSounds]::Asterisk.Play()" 2>/dev/null || true
  fi
}

notify_error() {
  local message="${1:-Ralphy encountered an error}"
  
  # macOS
  if command -v osascript &>/dev/null; then
    osascript -e "display notification \"$message\" with title \"Ralphy - Error\"" 2>/dev/null || true
  fi
  
  # Linux
  if command -v notify-send &>/dev/null; then
    notify-send -u critical "Ralphy - Error" "$message" 2>/dev/null || true
  fi
}

# ============================================
# AI ENGINE ABSTRACTION
# ============================================

run_ai_command() {
  local prompt=$1
  local output_file=$2
  
  case "$AI_ENGINE" in
    opencode)
      # OpenCode: use 'run' command with JSON format and permissive settings
      OPENCODE_PERMISSION='{"*":"allow"}' opencode run \
        --format json \
        --model google/gemini-3-pro-preview \
        --variant high \
        "$prompt" > "$output_file" 2>&1 &
      ;;
    cursor)
      # Cursor agent: use --print for non-interactive, --force to allow all commands
      agent --print --force \
        --output-format stream-json \
        "$prompt" > "$output_file" 2>&1 &
      ;;
    qwen)
      # Qwen-Code: use CLI with JSON format and auto-approve tools
      qwen --output-format stream-json \
        --approval-mode yolo \
        -p "$prompt" > "$output_file" 2>&1 &
      ;;
    droid)
      # Droid: use exec with stream-json output and medium autonomy for development
      droid exec --output-format stream-json \
        --auto medium \
        "$prompt" > "$output_file" 2>&1 &
      ;;
    codex)
      CODEX_LAST_MESSAGE_FILE="${output_file}.last"
      rm -f "$CODEX_LAST_MESSAGE_FILE"
      codex exec --full-auto \
        --json \
        --output-last-message "$CODEX_LAST_MESSAGE_FILE" \
        "$prompt" > "$output_file" 2>&1 &
      ;;
    gemini)
      # Gemini CLI: use stream-json output with auto-approval
      gemini --output-format stream-json \
        --approval-mode yolo \
        "$prompt" > "$output_file" 2>&1 &
      ;;
    *)
      # Claude Code: use existing approach
      claude --dangerously-skip-permissions \
        --verbose \
        --output-format stream-json \
        -p "$prompt" > "$output_file" 2>&1 &
      ;;
  esac

  ai_pid=$!
}

parse_ai_result() {
  local result=$1
  local response=""
  local input_tokens=0
  local output_tokens=0
  local actual_cost="0"
  
  case "$AI_ENGINE" in
    opencode)
      # OpenCode JSON format: uses step_finish for tokens and text events for response
      local step_finish
      step_finish=$(echo "$result" | grep '"type":"step_finish"' | tail -1 || echo "")
      
      if [[ -n "$step_finish" ]]; then
        input_tokens=$(echo "$step_finish" | jq -r '.part.tokens.input // 0' 2>/dev/null || echo "0")
        output_tokens=$(echo "$step_finish" | jq -r '.part.tokens.output // 0' 2>/dev/null || echo "0")
        # OpenCode provides actual cost directly
        actual_cost=$(echo "$step_finish" | jq -r '.part.cost // 0' 2>/dev/null || echo "0")
      fi
      
      # Get text response from text events
      response=$(echo "$result" | grep '"type":"text"' | jq -rs 'map(.part.text // "") | join("")' 2>/dev/null || echo "")
      
      # If no text found, indicate task completed
      if [[ -z "$response" ]]; then
        response="Task completed"
      fi
      ;;
    cursor)
      # Cursor agent: parse stream-json output
      # Cursor doesn't provide token counts, but does provide duration_ms
      
      local result_line
      result_line=$(echo "$result" | grep '"type":"result"' | tail -1)
      
      if [[ -n "$result_line" ]]; then
        response=$(echo "$result_line" | jq -r '.result // "Task completed"' 2>/dev/null || echo "Task completed")
        # Cursor provides duration instead of tokens
        local duration_ms
        duration_ms=$(echo "$result_line" | jq -r '.duration_ms // 0' 2>/dev/null || echo "0")
        # Store duration in output_tokens field for now (we'll handle it specially)
        # Use negative value as marker that this is duration, not tokens
        if [[ "$duration_ms" =~ ^[0-9]+$ ]] && [[ "$duration_ms" -gt 0 ]]; then
          # Encode duration: store as-is, we track separately
          actual_cost="duration:$duration_ms"
        fi
      fi
      
      # Get response from assistant message if result is empty
      if [[ -z "$response" ]] || [[ "$response" == "Task completed" ]]; then
        local assistant_msg
        assistant_msg=$(echo "$result" | grep '"type":"assistant"' | tail -1)
        if [[ -n "$assistant_msg" ]]; then
          response=$(echo "$assistant_msg" | jq -r '.message.content[0].text // .message.content // "Task completed"' 2>/dev/null || echo "Task completed")
        fi
      fi
      
      # Tokens remain 0 for Cursor (not available)
      input_tokens=0
      output_tokens=0
      ;;
    qwen)
      # Qwen-Code stream-json parsing (similar to Claude Code)
      local result_line
      result_line=$(echo "$result" | grep '"type":"result"' | tail -1)

      if [[ -n "$result_line" ]]; then
        response=$(echo "$result_line" | jq -r '.result // "No result text"' 2>/dev/null || echo "Could not parse result")
        input_tokens=$(echo "$result_line" | jq -r '.usage.input_tokens // 0' 2>/dev/null || echo "0")
        output_tokens=$(echo "$result_line" | jq -r '.usage.output_tokens // 0' 2>/dev/null || echo "0")
      fi

      # Fallback when no response text was parsed, similar to OpenCode behavior
      if [[ -z "$response" ]]; then
        response="Task completed"
      fi
      ;;
    droid)
      # Droid stream-json parsing
      # Look for completion event which has the final result
      local completion_line
      completion_line=$(echo "$result" | grep '"type":"completion"' | tail -1)

      if [[ -n "$completion_line" ]]; then
        response=$(echo "$completion_line" | jq -r '.finalText // "Task completed"' 2>/dev/null || echo "Task completed")
        # Droid provides duration_ms in completion event
        local dur_ms
        dur_ms=$(echo "$completion_line" | jq -r '.durationMs // 0' 2>/dev/null || echo "0")
        if [[ "$dur_ms" =~ ^[0-9]+$ ]] && [[ "$dur_ms" -gt 0 ]]; then
          # Store duration for tracking
          actual_cost="duration:$dur_ms"
        fi
      fi

      # Tokens remain 0 for Droid (not exposed in exec mode)
      input_tokens=0
      output_tokens=0
      ;;
    gemini)
      # Gemini CLI stream-json parsing
      # Extract stats from final result event
      local result_line
      result_line=$(echo "$result" | grep '"type":"result"' | tail -1)

      if [[ -n "$result_line" ]]; then
        # Try .stats first (current assumption), fallback to .usage
        input_tokens=$(echo "$result_line" | jq -r '.stats.input_tokens // .usage.input_tokens // 0' 2>/dev/null || echo "0")
        output_tokens=$(echo "$result_line" | jq -r '.stats.output_tokens // .usage.output_tokens // 0' 2>/dev/null || echo "0")

        # Extract duration for tracking
        local duration_ms
        duration_ms=$(echo "$result_line" | jq -r '.stats.duration_ms // 0' 2>/dev/null || echo "0")
        if [[ "$duration_ms" =~ ^[0-9]+$ ]] && [[ "$duration_ms" -gt 0 ]]; then
          actual_cost="duration:$duration_ms"
        fi
      fi

      # Extract response from assistant messages
      # Collect all assistant message deltas and concatenate
      response=$(echo "$result" | grep '"type":"message"' | grep '"role":"assistant"' | jq -rs 'map(.content // "") | join("")' 2>/dev/null || echo "")

      # Fallback to task completed if no response found
      if [[ -z "$response" ]]; then
        response="Task completed"
      fi
      ;;
    codex)
      if [[ -n "$CODEX_LAST_MESSAGE_FILE" ]] && [[ -f "$CODEX_LAST_MESSAGE_FILE" ]]; then
        response=$(cat "$CODEX_LAST_MESSAGE_FILE" 2>/dev/null || echo "")
        # Codex sometimes prefixes a generic completion line; drop it for readability.
        response=$(printf '%s' "$response" | sed '1{/^Task completed successfully\.[[:space:]]*$/d;}')
      fi
      input_tokens=0
      output_tokens=0
      ;;
    *)
      # Claude Code stream-json parsing
      local result_line
      result_line=$(echo "$result" | grep '"type":"result"' | tail -1)
      
      if [[ -n "$result_line" ]]; then
        response=$(echo "$result_line" | jq -r '.result // "No result text"' 2>/dev/null || echo "Could not parse result")
        input_tokens=$(echo "$result_line" | jq -r '.usage.input_tokens // 0' 2>/dev/null || echo "0")
        output_tokens=$(echo "$result_line" | jq -r '.usage.output_tokens // 0' 2>/dev/null || echo "0")
      fi
      ;;
  esac

  # Sanitize token counts
  [[ "$input_tokens" =~ ^[0-9]+$ ]] || input_tokens=0
  [[ "$output_tokens" =~ ^[0-9]+$ ]] || output_tokens=0

  # Debug output for token extraction (only if VERBOSE=true)
  if [[ "${VERBOSE:-false}" == true ]]; then
    echo "DEBUG: Extracted tokens - Input: $input_tokens, Output: $output_tokens, Cost: $actual_cost" >&2
  fi

  echo "$response"
  echo "---TOKENS---"
  echo "$input_tokens"
  echo "$output_tokens"
  echo "$actual_cost"
}

check_for_errors() {
  local result=$1
  
  if echo "$result" | grep -q '"type":"error"'; then
    local error_msg
    error_msg=$(echo "$result" | grep '"type":"error"' | head -1 | jq -r '.error.message // .message // .' 2>/dev/null || echo "Unknown error")
    echo "$error_msg"
    return 1
  fi
  
  return 0
}

# ============================================
# COST CALCULATION
# ============================================

calculate_cost() {
  local input=$1
  local output=$2

  if command -v bc &>/dev/null; then
    # Claude Opus 4.5 pricing: $5/MTok input, $25/MTok output
    echo "scale=4; ($input * 0.000005) + ($output * 0.000025)" | bc
  else
    echo "N/A"
  fi
}

# ============================================
# SINGLE TASK EXECUTION
# ============================================

run_single_task() {
  local task_name="${1:-}"
  local task_num="${2:-$iteration}"
  
  retry_count=0
  
  echo ""
  echo "${BOLD}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${RESET}"

  # Calculate progress for this session
  local remaining
  remaining=$(count_remaining_tasks | tr -d '[:space:]')
  remaining=${remaining:-0}

  # Calculate total tasks in this session (tasks completed so far + remaining)
  local session_completed=$((task_num - 1))
  local session_total=$((session_completed + remaining))

  # Task number and progress
  if [[ $session_total -gt 0 ]]; then
    echo "${BOLD}â”ƒ${RESET} ${CYAN}Task $task_num of $session_total${RESET}"
  else
    echo "${BOLD}â”ƒ${RESET} ${CYAN}Task $task_num${RESET}"
  fi

  # Get current task for display
  local current_task
  if [[ -n "$task_name" ]]; then
    current_task="$task_name"
  else
    current_task=$(get_next_task)
  fi

  # Task title (first 60 chars)
  if [[ -n "$current_task" ]]; then
    local task_title="${current_task:0:60}"
    echo "${BOLD}â”ƒ${RESET} $task_title"
  fi

  echo "${BOLD}â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${RESET}"

  # Show progress bar (uses session_completed and session_total calculated above)
  if [[ $session_total -gt 0 ]]; then
    show_progress_bar "$session_completed" "$session_total"
  fi
  
  if [[ -z "$current_task" ]]; then
    log_info "No more tasks found"
    return 2
  fi

  # Mark task as in_progress to prevent other instances from picking it up
  mark_task_in_progress "$current_task"

  current_step="Thinking"

  # Create branch if needed
  local branch_name=""
  if [[ "$BRANCH_PER_TASK" == true ]]; then
    branch_name=$(create_task_branch "$current_task")
    log_info "Working on branch: $branch_name"
  fi

  # Temp file for AI output
  tmpfile=$(mktemp)

  # Build the prompt
  local prompt
  prompt=$(build_beads_prompt "$current_task")

  if [[ "$DRY_RUN" == true ]]; then
    log_info "DRY RUN - Would execute:"
    echo "${DIM}$prompt${RESET}"
    rm -f "$tmpfile"
    tmpfile=""
    return_to_base_branch
    return 0
  fi

  # Run with retry logic
  while [[ $retry_count -lt $MAX_RETRIES ]]; do
    # Start AI command
    run_ai_command "$prompt" "$tmpfile"

    # Start progress monitor in background
    monitor_progress "$tmpfile" "${current_task:0:40}" &
    monitor_pid=$!

    # Wait for AI to finish
    wait "$ai_pid" 2>/dev/null || true

    # Stop the monitor
    kill "$monitor_pid" 2>/dev/null || true
    wait "$monitor_pid" 2>/dev/null || true
    monitor_pid=""

    # Show completion
    tput cr 2>/dev/null || printf "\r"
    tput el 2>/dev/null || true

    # Read result
    local result
    result=$(cat "$tmpfile" 2>/dev/null || echo "")

    # Check for empty response
    if [[ -z "$result" ]]; then
      ((retry_count++)) || true
      log_error "Empty response (attempt $retry_count/$MAX_RETRIES)"
      if [[ $retry_count -lt $MAX_RETRIES ]]; then
        log_info "Retrying in ${RETRY_DELAY}s..."
        sleep "$RETRY_DELAY"
        continue
      fi
      rm -f "$tmpfile"
      tmpfile=""
      return_to_base_branch
      mark_task_failed "$current_task"
      return 1
    fi

    # Check for API errors
    local error_msg
    if ! error_msg=$(check_for_errors "$result"); then
      ((retry_count++)) || true
      log_error "API error: $error_msg (attempt $retry_count/$MAX_RETRIES)"
      if [[ $retry_count -lt $MAX_RETRIES ]]; then
        log_info "Retrying in ${RETRY_DELAY}s..."
        sleep "$RETRY_DELAY"
        continue
      fi
      rm -f "$tmpfile"
      tmpfile=""
      return_to_base_branch
      mark_task_failed "$current_task"
      return 1
    fi

    # Parse the result
    local parsed
    parsed=$(parse_ai_result "$result")
    local response
    response=$(echo "$parsed" | sed '/^---TOKENS---$/,$d')
    local token_data
    token_data=$(echo "$parsed" | sed -n '/^---TOKENS---$/,$p' | tail -3)
    local input_tokens
    input_tokens=$(echo "$token_data" | sed -n '1p')
    local output_tokens
    output_tokens=$(echo "$token_data" | sed -n '2p')
    local actual_cost
    actual_cost=$(echo "$token_data" | sed -n '3p')

    printf "  ${GREEN}âœ“${RESET} %-16s â”‚ %s\n" "Done" "${current_task:0:40}"
    
    if [[ -n "$response" ]]; then
      echo ""
      echo "$response"
    fi

    # Sanitize values
    [[ "$input_tokens" =~ ^[0-9]+$ ]] || input_tokens=0
    [[ "$output_tokens" =~ ^[0-9]+$ ]] || output_tokens=0

    # Warn if tokens are zero for engines that should have token counts
    if [[ "$AI_ENGINE" != "cursor" ]] && [[ "$AI_ENGINE" != "droid" ]] && [[ "$AI_ENGINE" != "codex" ]]; then
      if [[ "$input_tokens" -eq 0 ]] && [[ "$output_tokens" -eq 0 ]]; then
        echo "âš ï¸  Warning: Zero tokens extracted for $AI_ENGINE engine" >&2
      fi
    fi

    # Update totals
    total_input_tokens=$((total_input_tokens + input_tokens))
    total_output_tokens=$((total_output_tokens + output_tokens))
    
    # Track actual cost for OpenCode, or duration for Cursor
    if [[ -n "$actual_cost" ]]; then
      if [[ "$actual_cost" == duration:* ]]; then
        # Cursor duration tracking
        local dur_ms="${actual_cost#duration:}"
        [[ "$dur_ms" =~ ^[0-9]+$ ]] && total_duration_ms=$((total_duration_ms + dur_ms))
      elif [[ "$actual_cost" != "0" ]] && command -v bc &>/dev/null; then
        # OpenCode cost tracking
        total_actual_cost=$(echo "scale=6; $total_actual_cost + $actual_cost" | bc 2>/dev/null || echo "$total_actual_cost")
      fi
    fi

    rm -f "$tmpfile"
    tmpfile=""
    if [[ "$AI_ENGINE" == "codex" ]] && [[ -n "$CODEX_LAST_MESSAGE_FILE" ]]; then
      rm -f "$CODEX_LAST_MESSAGE_FILE"
      CODEX_LAST_MESSAGE_FILE=""
    fi

    # Create PR if requested
    if [[ "$CREATE_PR" == true ]] && [[ -n "$branch_name" ]]; then
      create_pull_request "$branch_name" "$current_task" "Automated implementation by Ralphy"
    fi

    # Return to base branch
    return_to_base_branch

    # Check if AI signaled completion
    if [[ "$result" == *"<promise>COMPLETE</promise>"* ]]; then
      log_debug "AI signaled task completion"

      # Verify git working directory is clean (excluding .beads/ internal files)
      local uncommitted_changes
      uncommitted_changes=$(git status --porcelain | grep -v '^.. .beads/')

      if [[ -n "$uncommitted_changes" ]]; then
        log_warn "Task marked complete but uncommitted changes detected"
        log_warn "The agent may have forgotten to commit. Uncommitted changes:"
        echo "$uncommitted_changes"
        log_info "Reverting task to open status for retry"
        mark_task_failed "$current_task"
      else
        # Working directory is clean (ignoring .beads/ metadata), safe to mark complete
        log_debug "Working directory clean, marking task complete in beads"
        mark_task_complete "$current_task"

        # Check if parent epic should be closed
        local task_id=$(echo "$current_task" | cut -d: -f1)
        check_and_close_parent_epic "$task_id"
      fi
    else
      # AI did not signal completion - revert to open for retry
      log_debug "AI did not signal completion, reverting task to open"
      mark_task_failed "$current_task"
    fi

    # Check for completion - verify by actually counting remaining tasks
    local remaining_count
    remaining_count=$(count_remaining_tasks | tr -d '[:space:]' | head -1)
    remaining_count=${remaining_count:-0}
    [[ "$remaining_count" =~ ^[0-9]+$ ]] || remaining_count=0

    if [[ "$remaining_count" -eq 0 ]]; then
      return 2  # All tasks actually complete
    fi

    return 0
  done

  return_to_base_branch
  mark_task_failed "$current_task"
  return 1
}

# ============================================
# PARALLEL TASK EXECUTION
# ============================================

# Create an isolated worktree for a parallel agent
create_agent_worktree() {
  local task_name="$1"
  local agent_num="$2"
  local branch_name="ralphy/agent-${agent_num}-$(slugify "$task_name")"
  local worktree_dir="${WORKTREE_BASE}/agent-${agent_num}"
  
  # Run git commands from original directory
  # All git output goes to stderr so it doesn't interfere with our return value
  (
    cd "$ORIGINAL_DIR" || { echo "Failed to cd to $ORIGINAL_DIR" >&2; exit 1; }
    
    # Prune any stale worktrees first
    git worktree prune >&2
    
    # Delete branch if it exists (force)
    git branch -D "$branch_name" >&2 2>/dev/null || true
    
    # Create branch from base
    git branch "$branch_name" "$BASE_BRANCH" >&2 || { echo "Failed to create branch $branch_name from $BASE_BRANCH" >&2; exit 1; }
    
    # Remove existing worktree dir if any
    rm -rf "$worktree_dir" 2>/dev/null || true
    
    # Create worktree
    git worktree add "$worktree_dir" "$branch_name" >&2 || { echo "Failed to create worktree at $worktree_dir" >&2; exit 1; }
  )
  
  # Only output the result - git commands above send their output to stderr
  echo "$worktree_dir|$branch_name"
}

# Cleanup worktree after agent completes
cleanup_agent_worktree() {
  local worktree_dir="$1"
  local branch_name="$2"
  local log_file="${3:-}"
  local dirty=false

  if [[ -d "$worktree_dir" ]]; then
    if git -C "$worktree_dir" status --porcelain 2>/dev/null | grep -q .; then
      dirty=true
    fi
  fi

  if [[ "$dirty" == true ]]; then
    if [[ -n "$log_file" ]]; then
      echo "Worktree left in place due to uncommitted changes: $worktree_dir" >> "$log_file"
    fi
    return 0
  fi
  
  # Run from original directory
  (
    cd "$ORIGINAL_DIR" || exit 1
    git worktree remove -f "$worktree_dir" 2>/dev/null || true
  )
  # Don't delete branch - it may have commits we want to keep/PR
}

# Run a single agent in its own isolated worktree
run_parallel_agent() {
  local task_name="$1"
  local agent_num="$2"
  local output_file="$3"
  local status_file="$4"
  local log_file="$5"
  
  echo "setting up" > "$status_file"
  
  # Log setup info
  echo "Agent $agent_num starting for task: $task_name" >> "$log_file"
  echo "ORIGINAL_DIR=$ORIGINAL_DIR" >> "$log_file"
  echo "WORKTREE_BASE=$WORKTREE_BASE" >> "$log_file"
  echo "BASE_BRANCH=$BASE_BRANCH" >> "$log_file"
  
  # Disable beads daemon BEFORE creating worktree to prevent commits to wrong branch
  export BEADS_NO_DAEMON=1
  echo "Beads daemon disabled (BEADS_NO_DAEMON=1) for parallel mode safety" >> "$log_file"

  # Create isolated worktree for this agent
  local worktree_info
  worktree_info=$(create_agent_worktree "$task_name" "$agent_num" 2>>"$log_file")
  local worktree_dir="${worktree_info%%|*}"
  local branch_name="${worktree_info##*|}"

  echo "Worktree dir: $worktree_dir" >> "$log_file"
  echo "Branch name: $branch_name" >> "$log_file"
  
  if [[ ! -d "$worktree_dir" ]]; then
    echo "failed" > "$status_file"
    echo "ERROR: Worktree directory does not exist: $worktree_dir" >> "$log_file"
    echo "0 0" > "$output_file"
    return 1
  fi
  
  echo "running" > "$status_file"

  # Ensure .ralphy/ directory exists in worktree
  mkdir -p "$worktree_dir/$RALPHY_DIR"

  # Build prompt for this specific task
  local prompt="You are working on a specific task. Focus ONLY on this task:

TASK: $task_name

Instructions:
1. Implement this specific task completely
2. Write and run tests - all tests must pass
3. Run build - build must succeed without errors
4. Commit your changes with a descriptive message

When THIS TASK is complete, output <promise>COMPLETE</promise>
Focus only on implementing: $task_name"

  # Temp file for AI output
  local tmpfile
  tmpfile=$(mktemp)
  
  # Run AI agent in the worktree directory
  local result=""
  local success=false
  local retry=0

  while [[ $retry -lt $MAX_RETRIES ]]; do
    case "$AI_ENGINE" in
      opencode)
        (
          cd "$worktree_dir"
          OPENCODE_PERMISSION='{"*":"allow"}' opencode run \
            --format json \
            --model google/gemini-3-pro-preview \
            --variant high \
            "$prompt"
        ) > "$tmpfile" 2>>"$log_file"
        ;;
      cursor)
        (
          cd "$worktree_dir"
          agent --print --force \
            --output-format stream-json \
            "$prompt"
        ) > "$tmpfile" 2>>"$log_file"
        ;;
      qwen)
        (
          cd "$worktree_dir"
          qwen --output-format stream-json \
            --approval-mode yolo \
            -p "$prompt"
        ) > "$tmpfile" 2>>"$log_file"
        ;;
      droid)
        (
          cd "$worktree_dir"
          droid exec --output-format stream-json \
            --auto medium \
            "$prompt"
        ) > "$tmpfile" 2>>"$log_file"
        ;;
      codex)
        (
          cd "$worktree_dir"
          CODEX_LAST_MESSAGE_FILE="$tmpfile.last"
          rm -f "$CODEX_LAST_MESSAGE_FILE"
          codex exec --full-auto \
            --json \
            --output-last-message "$CODEX_LAST_MESSAGE_FILE" \
            "$prompt"
        ) > "$tmpfile" 2>>"$log_file"
        ;;
      gemini)
        (
          cd "$worktree_dir"
          gemini --output-format stream-json \
            --approval-mode yolo \
            "$prompt"
        ) > "$tmpfile" 2>>"$log_file"
        ;;
      *)
        (
          cd "$worktree_dir"
          claude --dangerously-skip-permissions \
            --verbose \
            --output-format stream-json \
            -p "$prompt"
        ) > "$tmpfile" 2>>"$log_file"
        ;;
    esac
    
    result=$(cat "$tmpfile" 2>/dev/null || echo "")
    
    if [[ -n "$result" ]]; then
      local error_msg
      if ! error_msg=$(check_for_errors "$result"); then
        ((retry++)) || true
        echo "API error: $error_msg (attempt $retry/$MAX_RETRIES)" >> "$log_file"
        sleep "$RETRY_DELAY"
        continue
      fi
      success=true
      break
    fi
    
    ((retry++)) || true
    echo "Retry $retry/$MAX_RETRIES after empty response" >> "$log_file"
    sleep "$RETRY_DELAY"
  done
  
  rm -f "$tmpfile"
  
  if [[ "$success" == true ]]; then
    # Parse tokens
    local parsed input_tokens output_tokens
    local CODEX_LAST_MESSAGE_FILE="${tmpfile}.last"
    parsed=$(parse_ai_result "$result")
    local token_data
    token_data=$(echo "$parsed" | sed -n '/^---TOKENS---$/,$p' | tail -3)
    input_tokens=$(echo "$token_data" | sed -n '1p')
    output_tokens=$(echo "$token_data" | sed -n '2p')
    [[ "$input_tokens" =~ ^[0-9]+$ ]] || input_tokens=0
    [[ "$output_tokens" =~ ^[0-9]+$ ]] || output_tokens=0

    # Debug: Log token extraction for parallel agents
    if [[ "${VERBOSE:-false}" == true ]]; then
      echo "DEBUG: Parallel agent tokens - Input: $input_tokens, Output: $output_tokens" >> "$log_file"
    fi

    rm -f "${tmpfile}.last"

    # Ensure at least one commit exists before marking success
    local commit_count
    commit_count=$(git -C "$worktree_dir" rev-list --count "$BASE_BRANCH"..HEAD 2>/dev/null || echo "0")
    [[ "$commit_count" =~ ^[0-9]+$ ]] || commit_count=0
    if [[ "$commit_count" -eq 0 ]]; then
      echo "ERROR: No new commits created; treating task as failed." >> "$log_file"
      echo "failed" > "$status_file"
      echo "0 0" > "$output_file"
      mark_task_failed_beads "$task_name"
      cleanup_agent_worktree "$worktree_dir" "$branch_name" "$log_file"
      return 1
    fi
    
    # Create PR if requested
    if [[ "$CREATE_PR" == true ]]; then
      (
        cd "$worktree_dir"
        git push -u origin "$branch_name" 2>>"$log_file" || true
        gh pr create \
          --base "$BASE_BRANCH" \
          --head "$branch_name" \
          --title "$task_name" \
          --body "Automated implementation by Ralphy (Agent $agent_num)" \
          ${PR_DRAFT:+--draft} 2>>"$log_file" || true
      )
    fi
    
    # Write success output
    echo "done" > "$status_file"
    echo "$input_tokens $output_tokens $branch_name" > "$output_file"
    
    # Cleanup worktree (but keep branch)
    cleanup_agent_worktree "$worktree_dir" "$branch_name" "$log_file"
    
    return 0
  else
    echo "failed" > "$status_file"
    echo "0 0" > "$output_file"
    mark_task_failed_beads "$task_name"
    cleanup_agent_worktree "$worktree_dir" "$branch_name" "$log_file"
    return 1
  fi
}

run_parallel_tasks() {
  log_info "Running ${BOLD}$MAX_PARALLEL parallel agents${RESET} (each in isolated worktree)..."
  
  local all_tasks=()
  
  # Get all pending tasks
  while IFS= read -r task; do
    [[ -n "$task" ]] && all_tasks+=("$task")
  done < <(get_all_tasks)
  
  if [[ ${#all_tasks[@]} -eq 0 ]]; then
    log_info "No tasks to run"
    return 2
  fi
  
  local total_tasks=${#all_tasks[@]}
  log_info "Found $total_tasks tasks to process"
  
  # Store original directory for git operations from subshells
  ORIGINAL_DIR=$(pwd)
  export ORIGINAL_DIR
  
  # Set up worktree base directory
  WORKTREE_BASE=$(mktemp -d)
  export WORKTREE_BASE
  log_debug "Worktree base: $WORKTREE_BASE"
  
  # Ensure we have a base branch set
  if [[ -z "$BASE_BRANCH" ]]; then
    BASE_BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "main")
  fi
  export BASE_BRANCH
  log_info "Base branch: $BASE_BRANCH"

  # Store original base branch for final merge (addresses Greptile review)
  # Using global variables so cleanup() can access them on interrupt
  ORIGINAL_BASE_BRANCH="$BASE_BRANCH"
  integration_branches=()  # Reset for this run

  # Export variables needed by subshell agents
  export AI_ENGINE MAX_RETRIES RETRY_DELAY BEADS_LABEL CREATE_PR PR_DRAFT

  local batch_num=0
  local completed_branches=()
  local levels=()

  # Get execution levels using BD dependency data
  while IFS= read -r level; do
    [[ -n "$level" ]] && levels+=("$level")
  done < <(get_beads_parallel_levels)

  if [[ ${#levels[@]} -eq 0 ]]; then
    log_warn "No execution levels found"
    return 0
  fi

  log_info "Found ${#levels[@]} execution levels"

  for level in "${levels[@]}"; do
    local tasks=()
    local level_label=" (level $level)"
    local group_completed_branches=()  # Track branches completed in this level

    log_info "Processing execution level $level..."

    # Get all tasks in this level
    while IFS= read -r task; do
      [[ -n "$task" ]] && tasks+=("$task")
    done < <(get_tasks_in_level_beads "$level")

    [[ ${#tasks[@]} -eq 0 ]] && continue
    log_info "Level $level has ${#tasks[@]} tasks"

    # Mark all tasks in level as in_progress
    for task in "${tasks[@]}"; do
      mark_task_in_progress_beads "$task"
    done

    local batch_start=0
    local total_group_tasks=${#tasks[@]}

    while [[ $batch_start -lt $total_group_tasks ]]; do
      ((batch_num++)) || true
      local batch_end=$((batch_start + MAX_PARALLEL))
      [[ $batch_end -gt $total_group_tasks ]] && batch_end=$total_group_tasks
      local batch_size=$((batch_end - batch_start))

      echo ""
      echo "${MAGENTA}â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®${RESET}"
      echo "${MAGENTA}â”‚${RESET} ${BOLD}âš¡ Batch $batch_num${level_label}:${RESET} Spawning $batch_size parallel agents"
      echo "${MAGENTA}â”‚${RESET} ${DIM}ðŸ”„ Each agent runs in its own git worktree${RESET}"
      echo "${MAGENTA}â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯${RESET}"
      echo ""

      # Setup arrays for this batch
      parallel_pids=()
      local batch_tasks=()
      local status_files=()
      local output_files=()
      local log_files=()

      # Show agent assignments with tree structure
      local display_agent_num=1
      for ((i = batch_start; i < batch_end; i++)); do
        local task="${tasks[$i]}"
        local task_short="${task:0:50}"

        if [[ $display_agent_num -eq 1 ]]; then
          echo "  ${CYAN}â”Œâ”€ Agent $display_agent_num${RESET} â”‚ $task_short"
        elif [[ $display_agent_num -eq $batch_size ]]; then
          echo "  ${CYAN}â””â”€ Agent $display_agent_num${RESET} â”‚ $task_short"
        else
          echo "  ${CYAN}â”œâ”€ Agent $display_agent_num${RESET} â”‚ $task_short"
        fi
        ((display_agent_num++))
      done

      echo ""

      # Start all agents in the batch
      for ((i = batch_start; i < batch_end; i++)); do
        local task="${tasks[$i]}"
        local agent_num=$((iteration + 1))
        ((iteration++)) || true

        local status_file=$(mktemp)
        local output_file=$(mktemp)
        local log_file=$(mktemp)

        batch_tasks+=("$task")
        status_files+=("$status_file")
        output_files+=("$output_file")
        log_files+=("$log_file")

        echo "waiting" > "$status_file"

        # Run agent in background
        (
          run_parallel_agent "$task" "$agent_num" "$output_file" "$status_file" "$log_file"
        ) &
        parallel_pids+=($!)
      done

      echo ""

      # Monitor progress with a spinner
      local spinner_chars='â ‹â ™â ¹â ¸â ¼â ´â ¦â §â ‡â '
      local spin_idx=0
      local start_time=$SECONDS

      while true; do
        # Check if all processes are done
        local all_done=true
        local setting_up=0
        local running=0
        local done_count=0
        local failed_count=0

        for ((j = 0; j < batch_size; j++)); do
          local pid="${parallel_pids[$j]}"
          local status_file="${status_files[$j]}"
          local status=$(cat "$status_file" 2>/dev/null || echo "waiting")

          case "$status" in
            "setting up")
              all_done=false
              ((setting_up++)) || true
              ;;
            running)
              all_done=false
              ((running++)) || true
              ;;
            done)
              ((done_count++)) || true
              ;;
            failed)
              ((failed_count++)) || true
              ;;
            *)
              # Check if process is still running
              if kill -0 "$pid" 2>/dev/null; then
                all_done=false
              fi
              ;;
          esac
        done

        [[ "$all_done" == true ]] && break

        # Update spinner
        local elapsed=$((SECONDS - start_time))
        local spin_char="${spinner_chars:$spin_idx:1}"
        spin_idx=$(( (spin_idx + 1) % ${#spinner_chars} ))

        printf "\r  ${CYAN}%s${RESET} Agents: ${BLUE}%d setup${RESET} | ${YELLOW}%d running${RESET} | ${GREEN}%d done${RESET} | ${RED}%d failed${RESET} | %02d:%02d " \
          "$spin_char" "$setting_up" "$running" "$done_count" "$failed_count" $((elapsed / 60)) $((elapsed % 60))

        sleep 0.3
      done

      # Clear the spinner line
      printf "\r%100s\r" ""

      # Wait for all processes to fully complete
      for pid in "${parallel_pids[@]}"; do
        wait "$pid" 2>/dev/null || true
      done

      # Show final status for this batch
      echo ""
      echo "  ${CYAN}ðŸ“‹ Batch $batch_num Results${RESET}"

      for ((j = 0; j < batch_size; j++)); do
        local task="${batch_tasks[$j]}"
        local task_short="${task:0:40}"
        local status_file="${status_files[$j]}"
        local output_file="${output_files[$j]}"
        local log_file="${log_files[$j]}"
        local status=$(cat "$status_file" 2>/dev/null || echo "unknown")
        local agent_num=$((iteration - batch_size + j + 1))

        # Determine tree character
        local tree_char="â”œâ”€"
        [[ $j -eq $((batch_size - 1)) ]] && tree_char="â””â”€"

        local icon color info=""
        case "$status" in
          done)
            icon="${GREEN}âœ“${RESET}"
            # Collect tokens and branch name
            local output_data=$(cat "$output_file" 2>/dev/null || echo "0 0")
            local in_tok=$(echo "$output_data" | awk '{print $1}')
            local out_tok=$(echo "$output_data" | awk '{print $2}')
            local branch=$(echo "$output_data" | awk '{print $3}')

            # Validate and sanitize
            [[ "$in_tok" =~ ^[0-9]+$ ]] || in_tok=0
            [[ "$out_tok" =~ ^[0-9]+$ ]] || out_tok=0

            # Warn if output file had no valid data
            if [[ "$AI_ENGINE" != "cursor" ]] && [[ "$AI_ENGINE" != "droid" ]] && [[ "$AI_ENGINE" != "codex" ]]; then
              if [[ "$in_tok" -eq 0 ]] && [[ "$out_tok" -eq 0 ]]; then
                echo "âš ï¸  Warning: No token data found in $output_file for task: $task" >&2
              fi
            fi

            total_input_tokens=$((total_input_tokens + in_tok))
            total_output_tokens=$((total_output_tokens + out_tok))

            # Format token info
            if [[ $in_tok -gt 0 ]] || [[ $out_tok -gt 0 ]]; then
              local in_fmt=$(format_token_count "$in_tok")
              local out_fmt=$(format_token_count "$out_tok")
              info="  ${DIM}[${in_fmt}â†’${out_fmt} tokens]${RESET}"
            fi

            if [[ -n "$branch" ]]; then
              completed_branches+=("$branch")
              group_completed_branches+=("$branch")  # Also track per-group
            fi

            # Mark task complete in beads
            mark_task_complete_beads "$task"

            # Check if parent epic should be closed
            local task_id=$(echo "$task" | cut -d: -f1)
            check_and_close_parent_epic "$task_id"
            ;;
          failed)
            icon="${RED}âœ—${RESET}"
            if [[ -s "$log_file" ]]; then
              info="  ${DIM}(error below)${RESET}"
            fi
            ;;
          *)
            icon="${YELLOW}?${RESET}"
            ;;
        esac

        echo "  $tree_char $icon ${CYAN}Agent $agent_num${RESET}  $task_short$info"

        # Show log for failed agents
        if [[ "$status" == "failed" ]] && [[ -s "$log_file" ]]; then
          echo "${DIM}    â”Œâ”€ Agent $agent_num log:${RESET}"
          sed 's/^/    â”‚ /' "$log_file" | head -20
          local log_lines=$(wc -l < "$log_file")
          if [[ $log_lines -gt 20 ]]; then
            echo "${DIM}    â”‚ ... ($((log_lines - 20)) more lines)${RESET}"
          fi
          echo "${DIM}    â””â”€${RESET}"
        fi

        # Cleanup temp files
        rm -f "$status_file" "$output_file" "$log_file"
      done

      batch_start=$batch_end

      # Check if we've hit max iterations
      if [[ $MAX_ITERATIONS -gt 0 ]] && [[ $iteration -ge $MAX_ITERATIONS ]]; then
        log_warn "Reached max iterations ($MAX_ITERATIONS)"
        break
      fi
    done

    # Sync beads state after level completes
    log_info "Level $level complete - syncing to remote..."
    bd sync 2>&1 | grep -v '^$' || log_warn "bd sync failed (non-fatal)"

    # After each level completes, merge branches into integration branch
    # so the next level sees the completed work (fixes issue #13)
    # NOTE: Uses git branch instead of git checkout to avoid changing HEAD while worktrees are active (Greptile review)
    if [[ ${#group_completed_branches[@]} -gt 0 ]] && [[ ${#levels[@]} -gt 1 ]]; then
      local integration_branch="ralphy/integration-level-$level"
      log_info "Creating integration branch for level $level: $integration_branch"

      # Create integration branch from current BASE_BRANCH without switching HEAD
      # This avoids state confusion while worktrees are active
      if git branch "$integration_branch" "$BASE_BRANCH" >/dev/null 2>&1; then
        local merge_failed=false
        local current_head
        current_head=$(git symbolic-ref --short HEAD 2>/dev/null || echo "")

        # Temporarily checkout the integration branch to perform merges
        if git checkout "$integration_branch" >/dev/null 2>&1; then
          for branch in "${group_completed_branches[@]}"; do
            log_debug "Merging $branch into $integration_branch"
            if ! git merge --no-edit "$branch" >/dev/null 2>&1; then
              log_warn "Conflict merging $branch into integration branch"
              # Abort the merge to leave branch in clean state (Greptile review)
              git merge --abort >/dev/null 2>&1 || true
              merge_failed=true
              break
            fi
          done

          # Return to original HEAD to avoid state confusion
          if [[ -n "$current_head" ]]; then
            git checkout "$current_head" >/dev/null 2>&1 || git checkout "$ORIGINAL_BASE_BRANCH" >/dev/null 2>&1 || true
          else
            git checkout "$ORIGINAL_BASE_BRANCH" >/dev/null 2>&1 || true
          fi

          if [[ "$merge_failed" == false ]]; then
            # Update BASE_BRANCH for next level
            BASE_BRANCH="$integration_branch"
            export BASE_BRANCH
            integration_branches+=("$integration_branch")  # Track for cleanup
            log_info "Updated BASE_BRANCH to $integration_branch for next level"
          else
            # Delete failed integration branch
            git branch -D "$integration_branch" >/dev/null 2>&1 || true
            log_warn "Integration merge failed; next level will branch from current BASE_BRANCH ($BASE_BRANCH)"
          fi
        else
          # Couldn't checkout, clean up the branch
          git branch -D "$integration_branch" >/dev/null 2>&1 || true
          log_warn "Could not checkout integration branch; next level will branch from current BASE_BRANCH ($BASE_BRANCH)"
        fi
      else
        log_warn "Could not create integration branch; next level will branch from current BASE_BRANCH ($BASE_BRANCH)"
      fi
    fi

    if [[ $MAX_ITERATIONS -gt 0 ]] && [[ $iteration -ge $MAX_ITERATIONS ]]; then
      break
    fi
  done

  # Final sync after all levels complete
  log_info "All levels complete - final sync..."
  bd sync 2>&1 | grep -v '^$' || log_warn "bd sync failed (non-fatal)"

  # Cleanup worktree base
  if ! find "$WORKTREE_BASE" -maxdepth 1 -type d -name 'agent-*' -print -quit 2>/dev/null | grep -q .; then
    rm -rf "$WORKTREE_BASE" 2>/dev/null || true
  else
    log_warn "Preserving worktree base with dirty agents: $WORKTREE_BASE"
  fi
  
  # Handle completed branches
  if [[ ${#completed_branches[@]} -gt 0 ]]; then
    echo ""
    echo "${BOLD}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${RESET}"

    if [[ "$CREATE_PR" == true ]]; then
      # PRs were created, just show the branches
      echo "${BOLD}Branches created by agents:${RESET}"
      for branch in "${completed_branches[@]}"; do
        echo "  ${CYAN}â€¢${RESET} $branch"
      done
    else
      # Auto-merge branches into ORIGINAL base branch (not integration branches)
      # This addresses Greptile review: final merge should use original base, not integration branch
      local final_target="$ORIGINAL_BASE_BRANCH"

      # If we used integration branches, the final integration branch contains all the work
      # We just need to merge the final integration branch into the original base
      if [[ ${#integration_branches[@]} -gt 0 ]]; then
        local final_integration="${integration_branches[${#integration_branches[@]}-1]}"  # Last integration branch (bash 3.2 compatible)
        echo "${BOLD}Merging integration branch into ${final_target}...${RESET}"
        echo ""

        if ! git checkout "$final_target" >/dev/null 2>&1; then
          log_warn "Could not checkout $final_target; leaving integration branch unmerged."
          echo "${BOLD}Integration branch: ${CYAN}$final_integration${RESET}"
          return 0
        fi

        printf "  Merging ${CYAN}%s${RESET}..." "$final_integration"
        if git merge --no-edit "$final_integration" >/dev/null 2>&1; then
          printf " ${GREEN}âœ“${RESET}\n"

          # Cleanup all integration branches after successful merge (Greptile review)
          echo ""
          echo "  ${DIM}ðŸ§¹ Cleanup${RESET}"

          # Count what we're deleting
          local int_count=${#integration_branches[@]}
          local agent_count=${#completed_branches[@]}

          # Show summary
          if [[ $int_count -gt 0 ]] && [[ $agent_count -gt 0 ]]; then
            echo "  ${DIM}â”œâ”€ Deleted $int_count integration branch(es)${RESET}"
            echo "  ${DIM}â””â”€ Deleted $agent_count agent branch(es)${RESET}"
          elif [[ $int_count -gt 0 ]]; then
            echo "  ${DIM}â””â”€ Deleted $int_count integration branch(es)${RESET}"
          elif [[ $agent_count -gt 0 ]]; then
            echo "  ${DIM}â””â”€ Deleted $agent_count agent branch(es)${RESET}"
          fi

          # Actually delete branches (silently)
          for int_branch in "${integration_branches[@]}"; do
            git branch -D "$int_branch" >/dev/null 2>&1 || true
          done

          for branch in "${completed_branches[@]}"; do
            git branch -D "$branch" >/dev/null 2>&1 || true
          done
        else
          printf " ${YELLOW}conflict${RESET}\n"
          git merge --abort >/dev/null 2>&1 || true
          log_warn "Could not merge integration branch; leaving branches for manual resolution."
          echo "${BOLD}Integration branch: ${CYAN}$final_integration${RESET}"
          echo "${BOLD}Original base: ${CYAN}$final_target${RESET}"
        fi

        return 0
      fi

      # No integration branches - merge individual agent branches directly
      echo "${BOLD}Merging agent branches into ${final_target}...${RESET}"
      echo ""

      if ! git checkout "$final_target" >/dev/null 2>&1; then
        log_warn "Could not checkout $final_target; leaving agent branches unmerged."
        echo "${BOLD}Branches created by agents:${RESET}"
        for branch in "${completed_branches[@]}"; do
          echo "  ${CYAN}â€¢${RESET} $branch"
        done
        return 0
      fi

      local merge_failed=()
      
      for branch in "${completed_branches[@]}"; do
        printf "  Merging ${CYAN}%s${RESET}..." "$branch"
        
        # Attempt to merge
        if git merge --no-edit "$branch" >/dev/null 2>&1; then
          printf " ${GREEN}âœ“${RESET}\n"
          # Delete the branch after successful merge
          git branch -d "$branch" >/dev/null 2>&1 || true
        else
          printf " ${YELLOW}conflict${RESET}"
          merge_failed+=("$branch")
          # Don't abort yet - try AI resolution
        fi
      done
      
      # Use AI to resolve merge conflicts
      if [[ ${#merge_failed[@]} -gt 0 ]]; then
        echo ""
        echo "${BOLD}Using AI to resolve ${#merge_failed[@]} merge conflict(s)...${RESET}"
        echo ""
        
        local still_failed=()
        
        for branch in "${merge_failed[@]}"; do
          printf "  Resolving ${CYAN}%s${RESET}..." "$branch"
          
          # Get list of conflicted files
          local conflicted_files
          conflicted_files=$(git diff --name-only --diff-filter=U 2>/dev/null)
          
          if [[ -z "$conflicted_files" ]]; then
            # No conflicts found (maybe already resolved or aborted)
            git merge --abort 2>/dev/null || true
            git merge --no-edit "$branch" >/dev/null 2>&1 || {
              printf " ${RED}âœ—${RESET}\n"
              still_failed+=("$branch")
              git merge --abort 2>/dev/null || true
              continue
            }
            printf " ${GREEN}âœ“${RESET}\n"
            git branch -d "$branch" >/dev/null 2>&1 || true
            continue
          fi
          
          # Build prompt for AI to resolve conflicts
          local resolve_prompt="You are resolving a git merge conflict. The following files have conflicts:

$conflicted_files

For each conflicted file:
1. Read the file to see the conflict markers (<<<<<<< HEAD, =======, >>>>>>> branch)
2. Understand what both versions are trying to do
3. Edit the file to resolve the conflict by combining both changes intelligently
4. Remove all conflict markers
5. Make sure the resulting code is valid and compiles

After resolving all conflicts:
1. Run 'git add' on each resolved file
2. Run 'git commit --no-edit' to complete the merge

Be careful to preserve functionality from BOTH branches. The goal is to integrate all features."

          # Run AI to resolve conflicts
          # Temporarily disable errexit since AI may fail
          set +e
          local ai_exit_code=0

          case "$AI_ENGINE" in
            opencode)
              OPENCODE_PERMISSION='{"*":"allow"}' opencode run \
                --format json \
                "$resolve_prompt" 2>&1
              ai_exit_code=$?
              ;;
            cursor)
              agent --print --force \
                --output-format stream-json \
                "$resolve_prompt" 2>&1
              ai_exit_code=$?
              ;;
            qwen)
              qwen --output-format stream-json \
                --approval-mode yolo \
                -p "$resolve_prompt" 2>&1
              ai_exit_code=$?
              ;;
            droid)
              droid exec --output-format stream-json \
                --auto medium \
                "$resolve_prompt" 2>&1
              ai_exit_code=$?
              ;;
            codex)
              codex exec --full-auto \
                --json \
                "$resolve_prompt" 2>&1
              ai_exit_code=$?
              ;;
            gemini)
              gemini --output-format stream-json \
                --approval-mode yolo \
                "$resolve_prompt" 2>&1
              ai_exit_code=$?
              ;;
            *)
              claude --dangerously-skip-permissions \
                -p "$resolve_prompt" \
                --output-format stream-json 2>&1
              ai_exit_code=$?
              ;;
          esac

          # Re-enable errexit
          set -e

          # Check if AI command failed
          if [[ $ai_exit_code -ne 0 ]]; then
            printf " ${RED}âœ— (AI error: exit code $ai_exit_code)${RESET}\n"
            still_failed+=("$branch")
            git merge --abort 2>/dev/null || true
            continue
          fi

          # Check if merge was completed
          if ! git diff --name-only --diff-filter=U 2>/dev/null | grep -q .; then
            # No more conflicts - merge succeeded
            printf " ${GREEN}âœ“ (AI resolved)${RESET}\n"
            git branch -d "$branch" >/dev/null 2>&1 || true
          else
            # Still has conflicts
            printf " ${RED}âœ— (AI couldn't resolve)${RESET}\n"
            still_failed+=("$branch")
            git merge --abort 2>/dev/null || true
          fi
        done
        
        if [[ ${#still_failed[@]} -gt 0 ]]; then
          echo ""
          echo "${YELLOW}Some conflicts could not be resolved automatically:${RESET}"
          for branch in "${still_failed[@]}"; do
            echo "  ${YELLOW}â€¢${RESET} $branch"
          done
          echo ""
          echo "${DIM}Resolve conflicts manually: git merge <branch>${RESET}"
        else
          echo ""
          echo "${GREEN}All branches merged successfully!${RESET}"
        fi
      else
        echo ""
        echo "${GREEN}All branches merged successfully!${RESET}"
      fi
    fi
  fi
  
  return 0
}

# ============================================
# SUMMARY
# ============================================

show_summary() {
  # Calculate overall duration
  if [[ -n "$BR_START_TIME" ]] && [[ -n "$BR_END_TIME" ]]; then
    BR_DURATION_SEC=$((BR_END_TIME - BR_START_TIME))
  fi

  echo ""
  echo "${BOLD}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${RESET}"
  echo "${BOLD}â•‘${RESET} ${GREEN}âœ“ All tasks complete!${RESET} Finished $iteration task(s)."
  echo "${BOLD}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${RESET}"
  echo ""

  # Cost summary with tree structure
  echo "  ${CYAN}ðŸ“Š Cost Summary${RESET}"

  if [[ "$AI_ENGINE" == "cursor" ]] || [[ "$AI_ENGINE" == "droid" ]]; then
    echo "  ${DIM}â”œâ”€ Token usage not available${RESET}"
    if [[ "$total_duration_ms" -gt 0 ]]; then
      local dur_sec=$((total_duration_ms / 1000))
      local dur_min=$((dur_sec / 60))
      local dur_sec_rem=$((dur_sec % 60))
      if [[ "$dur_min" -gt 0 ]]; then
        echo "  ${DIM}â””â”€ Total API time: ${dur_min}m ${dur_sec_rem}s${RESET}"
      else
        echo "  ${DIM}â””â”€ Total API time: ${dur_sec}s${RESET}"
      fi
    fi
  else
    # Format numbers with thousand separators
    local input_fmt=$(printf "%'d" "$total_input_tokens" 2>/dev/null || echo "$total_input_tokens")
    local output_fmt=$(printf "%'d" "$total_output_tokens" 2>/dev/null || echo "$total_output_tokens")
    local total_fmt=$(printf "%'d" "$((total_input_tokens + total_output_tokens))" 2>/dev/null || echo "$((total_input_tokens + total_output_tokens))")

    echo "  ${DIM}â”œâ”€ Input tokens:   $input_fmt${RESET}"
    echo "  ${DIM}â”œâ”€ Output tokens:  $output_fmt${RESET}"
    echo "  ${DIM}â”œâ”€ Total tokens:   $total_fmt${RESET}"

    # Calculate cost
    if [[ "$AI_ENGINE" == "opencode" ]] && command -v bc &>/dev/null; then
      local has_actual_cost
      has_actual_cost=$(echo "$total_actual_cost > 0" | bc 2>/dev/null || echo "0")
      if [[ "$has_actual_cost" == "1" ]]; then
        echo "  ${DIM}â””â”€ Actual cost:    \$${total_actual_cost}${RESET}"
      else
        local cost
        cost=$(calculate_cost "$total_input_tokens" "$total_output_tokens")
        echo "  ${DIM}â””â”€ Est. cost:      \$$cost${RESET}"
      fi
    else
      local cost
      cost=$(calculate_cost "$total_input_tokens" "$total_output_tokens")
      echo "  ${DIM}â””â”€ Est. cost:      \$$cost${RESET}"
    fi
  fi

  # Execution Time section
  if [[ -n "$BR_START_TIME" ]] && [[ -n "$BR_END_TIME" ]]; then
    echo ""
    echo "  ${CYAN}â±ï¸  Execution Time${RESET}"

    local hours=$((BR_DURATION_SEC / 3600))
    local minutes=$(((BR_DURATION_SEC % 3600) / 60))
    local seconds=$((BR_DURATION_SEC % 60))

    # Format start and end times
    local start_fmt=$(date -r "$BR_START_TIME" '+%Y-%m-%d %H:%M:%S' 2>/dev/null || echo "N/A")
    local end_fmt=$(date -r "$BR_END_TIME" '+%Y-%m-%d %H:%M:%S' 2>/dev/null || echo "N/A")

    echo "  ${DIM}â”œâ”€ Start:    $start_fmt${RESET}"
    echo "  ${DIM}â”œâ”€ End:      $end_fmt${RESET}"

    # Format duration
    if [[ "$hours" -gt 0 ]]; then
      echo "  ${DIM}â””â”€ Duration: ${hours}h ${minutes}m ${seconds}s${RESET}"
    elif [[ "$minutes" -gt 0 ]]; then
      echo "  ${DIM}â””â”€ Duration: ${minutes}m ${seconds}s${RESET}"
    else
      echo "  ${DIM}â””â”€ Duration: ${seconds}s${RESET}"
    fi
  fi

  # Branches with tree structure
  if [[ -n "${task_branches[*]+"${task_branches[*]}"}" ]]; then
    echo ""
    echo "  ${CYAN}ðŸŒ¿ Branches Created${RESET}"
    local branch_count=${#task_branches[@]}
    local i=1
    for branch in "${task_branches[@]}"; do
      if [[ $i -eq $branch_count ]]; then
        echo "  ${DIM}â””â”€ $branch${RESET}"
      else
        echo "  ${DIM}â”œâ”€ $branch${RESET}"
      fi
      ((i++))
    done
  fi

  echo ""
  echo "${BOLD}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${RESET}"
}

# ============================================
# MAIN
# ============================================

main() {
  BR_START_TIME=$(date +%s)
  parse_args "$@"

  # Handle --init mode
  if [[ "$INIT_MODE" == true ]]; then
    init_ralphy_config
    exit 0
  fi

  # Handle --config mode
  if [[ "$SHOW_CONFIG" == true ]]; then
    show_ralphy_config
    exit 0
  fi

  # Handle --add-rule
  if [[ -n "$ADD_RULE" ]]; then
    add_ralphy_rule "$ADD_RULE"
    exit 0
  fi

  # Handle single-task (brownfield) mode
  if [[ -n "$SINGLE_TASK" ]]; then
    # Set up cleanup trap
    trap cleanup EXIT
    trap 'exit 130' INT TERM HUP

    # Check basic requirements (AI engine, git, bd CLI)
    case "$AI_ENGINE" in
      claude) command -v claude &>/dev/null || { log_error "Claude Code CLI not found"; exit 1; } ;;
      opencode) command -v opencode &>/dev/null || { log_error "OpenCode CLI not found"; exit 1; } ;;
      cursor) command -v agent &>/dev/null || { log_error "Cursor agent CLI not found"; exit 1; } ;;
      codex) command -v codex &>/dev/null || { log_error "Codex CLI not found"; exit 1; } ;;
      qwen) command -v qwen &>/dev/null || { log_error "Qwen-Code CLI not found"; exit 1; } ;;
      droid) command -v droid &>/dev/null || { log_error "Factory Droid CLI not found"; exit 1; } ;;
      gemini) command -v gemini &>/dev/null || { log_error "Gemini CLI not found"; exit 1; } ;;
    esac

    if ! git rev-parse --git-dir >/dev/null 2>&1; then
      log_error "Not a git repository"
      exit 1
    fi

    # Check for bd CLI
    if ! command -v bd &>/dev/null; then
      log_error "bd CLI not found. Install beads CLI: https://github.com/beadslabs/beads"
      exit 1
    fi

    validate_config

    # Initialize .beads directory if missing
    if [[ ! -d ".beads" ]]; then
      log_info "Initializing .beads directory"
      if ! bd init >/dev/null 2>&1; then
        log_error "Failed to initialize .beads directory"
        exit 1
      fi
    fi

    # Show single task mode banner
    echo ""
    echo "${BOLD}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${RESET}"
    echo "${BOLD}â•‘${RESET} ${BOLD}${CYAN}ðŸ¤– Ralphy${RESET} - Single Task Mode (Beads Integration)"
    echo "${BOLD}â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${RESET}"

    # Engine
    local engine_display
    case "$AI_ENGINE" in
      opencode) engine_display="OpenCode" ;;
      cursor) engine_display="Cursor Agent" ;;
      codex) engine_display="Codex" ;;
      qwen) engine_display="Qwen-Code" ;;
      droid) engine_display="Factory Droid" ;;
      gemini) engine_display="Gemini CLI" ;;
      *) engine_display="Claude Code" ;;
    esac
    echo "${BOLD}â•‘${RESET} ${DIM}âš™ï¸  Engine:${RESET} $engine_display"

    # Bead type and labels
    local final_labels="ralph"
    if [[ -n "$BEAD_LABELS" ]]; then
      final_labels="ralph,${BEAD_LABELS}"
    fi
    echo "${BOLD}â•‘${RESET} ${DIM}ðŸ·ï¸  Type:${RESET} ${BEAD_TYPE}"
    echo "${BOLD}â•‘${RESET} ${DIM}ðŸ“Œ Labels:${RESET} ${final_labels}"

    # Config
    if [[ -d "$RALPHY_DIR" ]]; then
      local rules_count=0
      if [[ -f "$CONFIG_FILE" ]] && command -v yq &>/dev/null; then
        rules_count=$(yq -r '.rules // [] | length' "$CONFIG_FILE" 2>/dev/null)
      fi
      if [[ $rules_count -gt 0 ]]; then
        echo "${BOLD}â•‘${RESET} ${DIM}ðŸ“¦ Config:${RESET} $RALPHY_DIR/ ($rules_count rules loaded)"
      else
        echo "${BOLD}â•‘${RESET} ${DIM}ðŸ“¦ Config:${RESET} $RALPHY_DIR/"
      fi
    else
      echo "${BOLD}â•‘${RESET} ${DIM}ðŸ“¦ Config:${RESET} none (run --init to configure)"
    fi

    echo "${BOLD}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${RESET}"
    echo ""

    # Create bead from task
    log_info "Creating bead for task: $SINGLE_TASK"
    local bead_id
    if ! bead_id=$(create_bead_from_task "$SINGLE_TASK"); then
      log_error "Failed to create bead. Exiting."
      exit 1
    fi
    echo ""

    # Switch to beads mode to execute the single task
    # Clear SINGLE_TASK and set MAX_ITERATIONS=1 to execute only our new bead
    SINGLE_TASK=""
    MAX_ITERATIONS=1
    BEADS_LABEL="ralph"

    # Fall through to beads mode execution below
  fi

  if [[ "$DRY_RUN" == true ]] && [[ "$MAX_ITERATIONS" -eq 0 ]]; then
    MAX_ITERATIONS=1
  fi

  # Set up cleanup trap
  trap cleanup EXIT
  trap 'exit 130' INT TERM HUP

  # Check requirements
  check_requirements
  validate_config

  # Revert any orphaned in_progress tasks from previous runs
  log_debug "Checking for orphaned in_progress tasks..."
  revert_in_progress_tasks

  # Show banner
  echo ""
  echo "${BOLD}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${RESET}"
  echo "${BOLD}â•‘${RESET} ${BOLD}${CYAN}ðŸ¤– Beads-Ralphy${RESET}"
  echo "${BOLD}â•‘${RESET} Running until all tasks are complete"
  echo "${BOLD}â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${RESET}"

  # Engine
  local engine_display
  case "$AI_ENGINE" in
    opencode) engine_display="OpenCode" ;;
    cursor) engine_display="Cursor Agent" ;;
    codex) engine_display="Codex" ;;
    qwen) engine_display="Qwen-Code" ;;
    droid) engine_display="Factory Droid" ;;
    gemini) engine_display="Gemini CLI" ;;
    *) engine_display="Claude Code" ;;
  esac
  echo "${BOLD}â•‘${RESET} ${DIM}âš™ï¸  Engine:${RESET} $engine_display"

  # Source
  echo "${BOLD}â•‘${RESET} ${DIM}ðŸ“‹ Source:${RESET} beads (label: ${BEADS_LABEL:-ralph})"

  # Config
  if [[ -d "$RALPHY_DIR" ]]; then
    local rules_count=0
    if [[ -f "$CONFIG_FILE" ]] && command -v yq &>/dev/null; then
      rules_count=$(yq -r '.rules // [] | length' "$CONFIG_FILE" 2>/dev/null)
    fi
    if [[ $rules_count -gt 0 ]]; then
      echo "${BOLD}â•‘${RESET} ${DIM}ðŸ“¦ Config:${RESET} $RALPHY_DIR/ ($rules_count rules loaded)"
    else
      echo "${BOLD}â•‘${RESET} ${DIM}ðŸ“¦ Config:${RESET} $RALPHY_DIR/"
    fi
  fi

  # Mode (if any special modes enabled)
  local mode_parts=()
  [[ "$DRY_RUN" == true ]] && mode_parts+=("dry-run")
  [[ "$PARALLEL" == true ]] && mode_parts+=("parallel:$MAX_PARALLEL")
  [[ "$BRANCH_PER_TASK" == true ]] && mode_parts+=("branch-per-task")
  [[ "$CREATE_PR" == true ]] && mode_parts+=("create-pr")
  [[ $MAX_ITERATIONS -gt 0 ]] && mode_parts+=("max:$MAX_ITERATIONS")

  if [[ ${#mode_parts[@]} -gt 0 ]]; then
    echo "${BOLD}â•‘${RESET} ${DIM}ðŸ”§ Mode:${RESET} ${mode_parts[*]}"
  fi

  echo "${BOLD}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${RESET}"
  echo ""

  # Run in parallel or sequential mode
  if [[ "$PARALLEL" == true ]]; then
    run_parallel_tasks
    cleanup_all_completed_epics
    BR_END_TIME=$(date +%s)
    show_summary
    notify_done
    exit 0
  fi

  # Sequential main loop
  while true; do
    ((iteration++)) || true
    local result_code=0
    run_single_task "" "$iteration" || result_code=$?
    
    case $result_code in
      0)
        # Success, continue
        ;;
      1)
        # Error, but continue to next task
        log_warn "Task failed after $MAX_RETRIES attempts, continuing..."
        ;;
      2)
        # All tasks complete
        cleanup_all_completed_epics
        BR_END_TIME=$(date +%s)
        show_summary
        notify_done
        exit 0
        ;;
    esac

    # Sync beads state after each task (ensures BV sees updated status on next iteration)
    log_debug "Syncing beads state..."
    bd sync 2>&1 | grep -v '^$' || log_warn "bd sync failed (non-fatal)"

    # Check max iterations
    if [[ $MAX_ITERATIONS -gt 0 ]] && [[ $iteration -ge $MAX_ITERATIONS ]]; then
      log_warn "Reached max iterations ($MAX_ITERATIONS)"
      cleanup_all_completed_epics
      BR_END_TIME=$(date +%s)
      show_summary
      notify_done "Ralphy stopped after $MAX_ITERATIONS iterations"
      exit 0
    fi
    
    # Small delay between iterations
    sleep 1
  done
}

# Run main
main "$@"
